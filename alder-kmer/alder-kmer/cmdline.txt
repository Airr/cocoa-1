  "  -h, --help                   Print help of the program, or a command: e.g.,\n                                 alder-kmer count -h  (default=off)",
  "      --detailed-help          Print help, including all details  (default=off)",
  "      --full-help              Print help with documents  (default=off)",
  "\ncount:",
  "  The input files must be sequence files: fasta, or fastq. With no input files,\n  but with STDIN, version 2 or 3 runs are allowed because the number of kmers\n  cannot be estimated without input files. In version 2 or 3, the first stage\n  of generating a binary file would do the computation of total number of\n  kmers, and STDIN can be used. With STDIN, version 2 or 3 is used. With input\n  files, one of the three versions is used. By default, the table file would be\n  written to STDOUT unless --outfile is specified. A table file is accompanied\n  by its table header .tbh file. The numbers of iterations and partitions are\n  determined by the available disk space, memory, and input sequence data (see\n  Rizk et al. 2013 using --cite option). The program attempts to compute the\n  available disk space and memory at the time the program runs. This help\n  message shows the available disk space and memory below. Those values can be\n  changed whenever the program runs, and they can be different from the ones\n  below. You could specify disk space or available memory, and adjust the usage\n  of disk space and memory using load options: --load-disk and --load-memory.\n  You can also specify the number of iterations and partitions --ni and --np,\n  these will override values that otherwise would be determined by disk space\n  and input sequence data; this is not recommended for real data, but for\n  command `simulate'. Output file name prefix can be changed using --outfile,\n  and so can their location with --outdir. In version 6, the given total memory\n  is filled with input data, and the memory left-over is used for a partition\n  table. If the minimum memory for a partition table is not met, the version 6\n  is reduced to version 5. Because too large table may failed to be loaded onto\n  the memory space in other computers, the maximum memory for a partition table\n  can be set as well.",
  "      --count                  Count k-mer data  (default=off)",
  "  -k, --kmer=INT               k-mer size  (default=`1')",
  "      --disk=N MB              maximum disk space  (default=`10')",
  "      --load-disk=0 < x < 1    fraction of disk  (default=`1.0')",
  "      --memory=N MB            maximum memory  (default=`10')",
  "      --load-memory=0 < x < 1  fraction of memory  (default=`1.0')",
  "  -t, --nthread=INT>=1         number of threads  (default=`1')",
  "  -o, --outfile=FILENAME       prefix of output files  (default=`outfile')",
  "      --outdir=DIRECTORY       output directory  (default=`.')",
  "      --nh=INT                 number of hash elements  (default=`10')",
  "      --no-partition           Skip partitioning sequence files.  (default=off)",
  "      --no-count               Skip counting.  (default=off)",
  "      --no-delete              Do not delete partition files; on with\n                                 --no-count  (default=off)",
  "\ndump:",
  "  This command reports the table of kmers and their occurences in a table file.\n  The input file can be created either using `count', `table' or `simulate'\n  command. A hash table file name is suffixed with `tbl'.  It prints k-mer, its\n  reverse complementary sequence, the number of occurences, and the index of\n  the sequence in the table.",
  "      --report                 Report the count table  (default=off)",
  "      --summary                Display summary of the table  (default=off)",
  "      --fasta                  fasta format: >count newline kmer  (default=off)",
  "      --no-tab                 Space separator  (default=off)",
  "\nquery:",
  "  Query a count table in a kmer count table; this is given by option --tabfile\n  or the default name can be changed using option --outfile. A string of DNA\n  sequence can be given with option --sequence, or a set of DNA sequences can\n  be given by FASTA or FASTQ files.",
  "      --query                  dummy  (default=off)",
  "      --sequence=sequence      Query a kmer DNA sequence",
  "\nsimulate:",
  "  There are no input files for `simulate' command. Use --kmer to specifiy the\n  length of kmer sequences. By default, a sequence file would be written to\n  stdout if --nf option is given with 1 or a single sequence file is requested.\n  Set the number of kmers using --maxkmer. FASTQ or FASTA files can be\n  generated. A simple sequence file can also be created. Use --outfile and\n  --outdir options to create files.  The command can generate sequence and\n  partition files. Use --nf to change the number of files. Total number of\n  parition files with .par extension is equal to ni x np where ni is given by\n  option --ni and np is by --np.  See the reference papers for details using\n  option --cite. Data size is limited by the number of kmers. Data size can\n  also be limited by kmer size; e.g., however large the hash table size is, the\n  number of slots would be two if kmer size is 1. If kmer size is very large,\n  it is likely to have unique kmers.",
  "      --simulate               Simulate k-mer data  (default=off)",
  "      --maxkmer=INT < 10^8     number of kmers in a file  (default=`1000')",
  "      --format=STRING          generated sequence file format  (possible\n                                 values=\"fasta\", \"fastq\", \"fa\", \"fq\",\n                                 \"seq\" default=`fastq')",
  "      --ni=INT                 number of iterations  (default=`1')",
  "      --np=INT                 number of partitions  (default=`1')",
  "      --nf=INT                 number of sequences files  (default=`1')",
  "      --seqlen=INT             maximum sequence length  (default=`100')",
  "      --seed=INT < 10^9        random seed  (default=`-1')",
  "  Enter a positive integer seed (9 digits or less).",
  "\npartition:",
  "  This command converts sequence files to partition files. Use options of\n  command `simulate': --kmer, --nthread, --outfile, --outdir, --ni, and --np.\n  You can use options: --disk and --memory to set automatically --ni and --np,\n  but to use --disk and --memmory you must set --ni=-1 and --np=-1 or negative\n  values. Otherwise, --ni and --np values in `simulate' command would be used.\n  The --memory option value will be still used for acquiring buffers for\n  reading sequence files and writing partition files. Large memory would\n  increase the speed of `partition' command. On the contrary, the value in\n  --disk does not affect the buffer, and the performance of `partition' command\n  would be the same for different values of --disk, which would change the size\n  of --ni and --np if --ni=-1 and --np=-1. See the reference by Rizk, et al.\n  (2013) for details using option --cite.",
  "      --partition              Create a partition file  (default=off)",
  "      --inbuffer=INT           Size of input buffer in log2  (default=`0')",
  "      --outbuffer=INT          Size of output buffer in log2  (default=`0')",
  "\nkmer:",
  "  This command converts a partition file to a kmer sequence file. Available\n  options include --kmer, --outfile, and --outdir. Use the following commands\n  to convert the decoded kmers to a dumped table.\n  $cut -f 1 outfile.dec|sort|uniq -c|awk 'BEGIN{OFS=FS=\" \"}\n  {tmp=$1;$1=$2;$2=tmp;print}' > outfile.2",
  "      --decode                 Decode a partition file  (default=off)",
  "\ntable:",
  "  This command converts partition files to a table file. Use the following\n  options: --kmer, --nh, --nthread, and provide at least one partition file as\n  an input file.",
  "      --table                  Partition file  (default=off)",
  "\nlist:",
  "  This command lists kmer sequences in a fastq file. Kmer sequences should have\n  the four letters of A, C, G, and T. Any other characters, even a, c, g, or t,\n  are considered not a valid DNA letter. Available options include kmer,\n  seqlen.",
  "      --list                   List kmers in a text file. Options: kmer, seqlen\n                                 (default=off)",
  "\nmatch:",
  "  This command compares a table file and a set of input files. A set of\n  sequence data can be given as either standard input or input files.",
  "      --match                  Compare a table file and input sequence data.\n                                 (default=off)",
  "      --tabfile=FILENAME       a table file  (default=`outfile.tbl')",
  "\nbinary:",
  "  This command converts input sequence data to a alder-kmer binary file.",
  "      --binary                 Create a binary file from sequence file.\n                                 (default=off)",
  "\nuncompress:",
  "  This command converts alder-kmer binary files to a simple form of sequence\n  file. Without --outfile option, the output goes to STDOUT. With --outfile\n  option, a file with extension of .seq is created. This could be use to\n  compare a binary file from FASTQ files; use\n  $ awk 'NR % 4 == 2' file.fq > file.seq\n  and compare file.seq and the outfile from uncompress command. Use\n  command-line tool md5 to compare two files because files can be large.",
  "      --uncompress             Create a simple form of a sequence file from an\n                                 alder-kmer binary file.  (default=off)",
  "\ninspect:",
  "  This command inspects the computer that alder-kmer runs on.",
  "      --inspect                inspect command  (default=off)",
  "\nmore:",
  "      --cite                   Print reference papers",
  "      --log[=file]             Log file using option outfile\n                                 (default=`outfile.log')",
  "      --progress               Display progress  (default=off)",
  "      --loglevel=level         Log level  (possible values=\"0\", \"1\", \"2\",\n                                 \"3\", \"4\", \"5\" default=`1')",
  "      --progress-to-stderr     Display progress number to stdandard error\n                                 (default=off)",
  "      --totalmaxkmer=INT       Skip counting maximum number of kmers in data,\n                                 and use this number  (default=`0')",
  "      --select-version=INT     Select a version of kmer counting: 0 for\n                                 automatic selction, 1 for skipping binary file\n                                 creation (dsk mode with a single iteration), 2\n                                 for binary file creation (dsk mode), and 3 for\n                                 loading a whole input data on the memory (msk\n                                 or memory streaming kmer mode).  (possible\n                                 values=\"0\", \"1\", \"2\", \"3\" default=`0')",
  "      --bin-outdir=DIRECTORY   binary file output directory  (default=`.')",
  "      --par-outdir=DIRECTORY   partition files output directory  (default=`.')",
  "      --tab-outdir=DIRECTORY   table file output directory  (default=`.')",
  "  -m, --mer-len=INT            k-mer size  (default=`1')",
  "  -C, --canonical              Count both strand  (default=off)",
  "  -L, --lower-count=INT        minimum count  (default=`1')",
  "  -U, --upper-count=INT        maximum count  (default=`65535')",
  "      --size=INT               hash size  (default=`1')",
  "      --threads=INT>=1         number of threads  (default=`1')",
  "      --output=FILENAME        prefix of output files  (default=`outfile')",
  "      --with-reverse           Print reverse complementary sequences\n                                 (default=off)",
  "      --with-index             Print index values  (default=off)",
  "      --only-init              Do not execute counting, but the initialization\n                                 (default=off)",
  "      --with-parfile           Create par files as well as sequence files.\n                                 (default=off)",
  "      --min-table-memory=INT   min memory of a part table  (default=`100')",
  "      --max-table-memory=INT   max memory of a part table  (default=`1000')",
  "      --release                Release mode  (default=on)",
  "\nexit:",
  "  The alder-kmer exit 0 on success, and >0 if an error occurs. The command\n  `simulate' returns 0 if all of the Kmers occur only once, otherwise >0.",
  "      --exit                   dummy  (default=off)",
  "\nexamples:",
  "  The alder-kmer can take files of different formats depending on the given\n  command argument.\n\n  *** FILE FORMAT ***\n\n  FASTA: See http://en.wikipedia.org/wiki/FASTA_format for the format. Command\n  `simulate' can create fasta-format files.\n\n  FASTQ: See http://en.wikipedia.org/wiki/FASTQ_format for the format. Command\n  `simulate' can create fastq-format files.\n\n  TAB: This is a binary file format for files created by alder-kmer `count'\n  command. It contains a list of entries, of which each consists of a kmer, its\n  occurence, and the index. The index value could be used to search the table\n  for a particular kmer. Another command named `table' can create a table file\n  from a partition file.\n\n  BIN: Alder-kmer converts a set of input sequence files to a .bin file. A\n  binary file tends to be smaller in size, which allows alder-kmer to read a\n  whole input in each iteration more quickly than read sequence files. A binary\n  file is not created if only one iteration is estimated to be needed.\n\n  PAR: This is a binary file format for a partition. See Rizk et al. (2013) for\n  details of partitions. A file of the format contains kmer sequences of the\n  same kmer size. Commands `count'. `simulate', and `partition' can create\n  partition files.\n\n  DEC: This is a text file format of partition files. It simply prints one kmer\n  per line.\n\n  *** COUNT ***\n\n  Use one of the commands to execute alder-kmer. When demontrating usages of\n  alder-kmer, the first argument being always a command, I omit alder-kmer. For\n  instance, to count kmer of size 1 in file a.fa you can type in the following\n  command:\n  $ ./alder-kmer count a.fa\n  Instead, we write as follows:\n  $ count a.fa\n  So, please, always prepend the command with `alder-kmer'. If you need a test\n  sequence file, then see a following section to learn how to use `simulate'\n  command, which would create sequence files.\n\n  To count kmers (K=2) in a sequence file, using option -k, type in:\n  $ count -k 2 a.fa\n  This would create an output file named outfile.tbl.\n\n  *** REPORT ***\n\n  To list kmers and their occurences in a created hash table, type in:\n  $ report outfile.tbl\n\n  *** SIMULATE ***\n\n  Create a sequence file using `simulate' command.\n  $ simulate --seed=1\n  The command runs with default options. See the secion `simulate' command\n  above for detail or type in:\n  $ simulate -h\n  to learn options and default values of the command. The `simulate' command\n  would create a sequence file (outfile-00.fa) and a partition file\n  (outfile_0-0.par).\n\n  *** PARTITION ***\n\n  Let's recover the same partition file, which is a part of command `count'\n  using command `partition'.\n  $ partition outfile-00.fa\n  Because this command is part of simulation, it uses more options in command\n  `simulate' than those in `count'. The command would create a partition file:\n  outfile-0-0.par. This file and outfile_0-0.par should be same.  The partition\n  file contains kmers in bytes, which can be decoded by using command `decode'\n  with the partition file.\n\n  *** DECODE ***\n\n  To convert a partition file to a text file, type in:\n  $ decode outfile-0-0.par\n  The `decode' command generates an out file with .dec extension.\n\n  *** TABLE ***\n\n  To create the report file from a partition file, type in:\n  $ table outfile-0-0.par\n  This would create an output file named outfile.tbl.\n\n  *** LIST ***\n\n  *** MATCH ***\n\n  *** BINARY ***\n\n  *** UNCOMPRESS ***\n\n  $ ./alder-kmer u outfile.bin | md5\n  $ cat outfile.bin | ./alder-kmer u | md5\n\n  *** INSPECT ***\n\n  *** EXAMPLES ***\n\n  Let's consider these variables in testing.\n  K: kmer size\n  N: number of unique kmers (MAX of N=10^8)\n  M: occurence of each unique kmer\n  T: number of threads\n\n  1. Partition command test without consistency check (.fa/.fq -> .par)\n  K=1..62,N=10000,M=65535,T=1 \n  ./alder_kmer_test_partition.sh $K 10000 65535 fq no 1 3\n  K=1..62,N=10000,M=65535,T=4 (1 hour)\n  for K in {1..62}; do ./alder_kmer_test_partition.sh $K 10000 65535 fq no 4 3;\n  done\n\n  2. Table command test (.par -> .tbl)\n  K=1..62,N=1000,T=1\n  for K in {1..62}; do ./alder_kmer_test_table.sh $K 1000 fq no 1; done\n  K=1..62,N=1000,T=4\n  for K in {1..62}; do ./alder_kmer_test_table.sh $K 100000 fq no 4; done\n\n  3. Table command with larger data test\n  K=15..31,T=1\n  ./alder_kmer_test_table2.sh $K 10000 65535 fq no 10000 1000 1 3\n  K=15..31,T=4\n  for K in {32..186}; do ./alder_kmer_test_table2.sh $K 10000 65535 fq no 10000\n  1000 4 3; done\n  HERE\n\n  4. Count command test (.fa/.fq -> .tbl)\n  K=15..63,T=1\n  ./alder_kmer_test_count.sh $K 10000 65535 fq no 10000 1000 1 3\n  K=15..186,T=4\n  for K in {32..186}; do ./alder_kmer_test_count.sh $K 10000 65535 fq no 10000\n  1000 4 3; done\n  NEXT\n\n  5. Maximum of unique test\n  ./alder_kmer_test_partition.sh 15 100000000 1 fq no 1 3\n\n  6. Shuffle\n  K=32..200\n  for K in {32..99}; do ./alder_kmer_test_table3.sh $K 1000 fq no 10000 10 4 3\n  no; done\n  HERE on upto 99 because of lack of disk space.\n  for K in {32..99}; do ./alder_kmer_test_table3.sh $K 1000 fq no 10000 10 4 3\n  yes; done\n  NEXT (partially)\n\n  7. dsk's human data test using alder-kmer's list command\n\n\n  8. Multiple input files\n\n  . lz4\n\n  . FASTA\n\n  . gzip, bzip2\n\n  . dsk's test data\n\n  . K=32 .. 186\n\n  . T=1 .. 128 (using pacman and lemming)\n\n  . Test of overflow of occurence (create a separate file of kmer of\n  overflowed).\n  .ofl file would contain encoded numbers just like .par file.\n\n  TODO\n  3. Usage of table in percentage (should be 70%)\n\n  ### End of Examples ###",
  "      --examples               Shows example runs of alder-kmer  (default=off)",
  "\ndocument:",
  "  Title\n\n  Abstract\n  Counting K-mers in a nucleotide sequence data set is a basic step in further\n  analyses of the data. Computing environments can be diverse from personal\n  computers to high-end super computers. Diverse computing environments are\n  equiped with different limiting factors in terms of disk space, available\n  memory, and CPUs. Computing costs time and enerage. Efficient use of\n  available resources is important. I could have saved time and spend the spare\n  time on something else. Someone else could have used the resources for their\n  use. If disk space is cheaper than memory in computing environments such as\n  personal computers, using disk space would be beneficial. Disk space may not\n  be available in some high-end super computing environments, but more computer\n  memory could be available. I experiment with counting K-mers in different\n  computing environments to address which resources are limiting factors.\n\n  Introduction\n\n\n\n\n  Limited factors.\n  1. Disk space. Usually disk space is unlimited. In high-end computing\n  facilities, disk space tends to be more expensive than memory or available\n  CPUs. Reading and writing compressed files can be crucial in this disk space\n  limited computing environment.\n  2. Memory. Loading all of the sequence data in a single memory would allow me\n  to bypass the generation of partition files, and directly create a resulting\n  table file.\n  3. CPU cores. I cannot compensate limited memory by multiple CPUs.\n\n  Limted disk\n\n  Input data - 460g (uncompressed) 130g (gz compressed) 100g (bz2 compressed)\n  130g (lz4 compressed)\n  disk space - 100m, 1g, 10g, 100g, 1000g\n  memory     - 100m, 1g, 2g, 4g, 8g, 16g, 32g, 64g, (128g, 256g, 512g, 1024g,\n  2048g)\n  CPU        - 1, 2, 4, 8, 24, 16, 32, 64, 128\n  K          - 1 ... 256\n\n  Phases (compress, partition, table)\n  1. compress  - sequence data to a binary file\n  2. partition - a binary file to multiple partition files\n  3. table     - partition files to a table file\n\n  1. A single iteration - partition and table\n  2. large memory - compress and table\n\n  If the available memory is large enough to load a whole data set, I could\n  bypass the partition step and write the table directly.\n\n  I would avoid comparing alder-kmer with dsk or kmc because they are similar\n  in many ways. Besides, they are not as popular as Jellyfish. The CAS is a key\n  difference from dsk or kmc. I want to make a case that CAS with dsk or kmc\n  scheme would improve the disk-streaming kmer counting method in the computing\n  speed.\n\n  Differences from Jellyfish, dsk, kmc\n  1. Jellyfish - a table is made per partition\n  2. dsk - uses lock-free scheme or Jellyfish approach if more memory is\n  available\n  3. kmc - uses lock-free scheme\n\n  Commons with Jellyfish, dsk, kmc\n  1. Jellyfish - using CAS\n  2. dsk - same when the memory is limited\n  3. kmc - delicate multi-threaded design\n\n  Methods\n\n  Results\n\n  Discussions\n\n  References\n\n\n  Jellyfish\n\n  Marçais, G. & Kingsford, C. A fast, lock-free approach for efficient\n  parallel counting of occurrences of k-mers. Bioinformatics, Department of\n  Computer Science, University of Maryland, College Park, MD 20742, USA.\n  gmarcais@umd.edu, 2011, 27, 764-770\n\n  dsk (minia)\n\n  Rizk, G.; Lavenier, D. & Chikhi, R. DSK: k-mer counting with very low memory\n  usage. Bioinformatics, Algorizk, 75013 Paris, France., 2013, 29, 652-653\n\n  kmc\n\n  Deorowicz, S.; Debudaj-Grabysz, A. & Grabowski, S. Disk-based k-mer counting\n  on a PC. BMC Bioinformatics, Institute of Informatics, Silesian University of\n  Technology, Akademicka 16, 44-100 Gliwice, Poland.\n  sebastian.deorowicz@polsl.pl, 2013, 14, 160\n\n  BFCounter\n\n  Melsted, Pá. & Pritchard, J. K. Efficient counting of k-mers in DNA\n  sequences using a bloom filter. BMC Bioinformatics, Department of Human\n  Genetics, The University of Chicago, Chicago, IL 60637, USA.\n  pmelsted@gmail.com, 2011, 12, 333\n\n  khmer\n\n  Pell, J.; Hintze, A.; Canino-Koning, R.; Howe, A.; Tiedje, J. M. & Brown, C.\n  T. Scaling metagenome sequence assembly with probabilistic de Bruijn graphs\n  Proceedings of the National Academy of Sciences, National Acad Sciences,\n  2012, 109, 13272-13277\n  https://github.com/ctb/khmer\n\n  de Bruijn graphs\n\n  Compeau, P. E.; Pevzner, P. A. & Tesler, G. How to apply de Bruijn graphs to\n  genome assembly Nature biotechnology, Nature Publishing Group, 2011, 29,\n  987-991\n\n  ### End of Document ###",
  "      --document               Shows the document for alder-kmer  (default=off)",
    0
};
static void
init_full_help_array(void)
{
  gengetopt_args_info_full_help[0] = gengetopt_args_info_detailed_help[0];
  gengetopt_args_info_full_help[1] = gengetopt_args_info_detailed_help[1];
  gengetopt_args_info_full_help[2] = gengetopt_args_info_detailed_help[2];
  gengetopt_args_info_full_help[3] = gengetopt_args_info_detailed_help[3];
  gengetopt_args_info_full_help[4] = gengetopt_args_info_detailed_help[4];
  gengetopt_args_info_full_help[5] = gengetopt_args_info_detailed_help[5];
  gengetopt_args_info_full_help[6] = gengetopt_args_info_detailed_help[6];
  gengetopt_args_info_full_help[7] = gengetopt_args_info_detailed_help[7];
  gengetopt_args_info_full_help[8] = gengetopt_args_info_detailed_help[8];
  gengetopt_args_info_full_help[9] = gengetopt_args_info_detailed_help[9];
  gengetopt_args_info_full_help[10] = gengetopt_args_info_detailed_help[10];
  gengetopt_args_info_full_help[11] = gengetopt_args_info_detailed_help[11];
  gengetopt_args_info_full_help[12] = gengetopt_args_info_detailed_help[12];
  gengetopt_args_info_full_help[13] = gengetopt_args_info_detailed_help[13];
  gengetopt_args_info_full_help[14] = gengetopt_args_info_detailed_help[14];
  gengetopt_args_info_full_help[15] = gengetopt_args_info_detailed_help[15];
  gengetopt_args_info_full_help[16] = gengetopt_args_info_detailed_help[16];
  gengetopt_args_info_full_help[17] = gengetopt_args_info_detailed_help[17];
  gengetopt_args_info_full_help[18] = gengetopt_args_info_detailed_help[18];
  gengetopt_args_info_full_help[19] = gengetopt_args_info_detailed_help[19];
  gengetopt_args_info_full_help[20] = gengetopt_args_info_detailed_help[20];
  gengetopt_args_info_full_help[21] = gengetopt_args_info_detailed_help[21];
  gengetopt_args_info_full_help[22] = gengetopt_args_info_detailed_help[22];
  gengetopt_args_info_full_help[23] = gengetopt_args_info_detailed_help[23];
  gengetopt_args_info_full_help[24] = gengetopt_args_info_detailed_help[24];
  gengetopt_args_info_full_help[25] = gengetopt_args_info_detailed_help[25];
  gengetopt_args_info_full_help[26] = gengetopt_args_info_detailed_help[26];
  gengetopt_args_info_full_help[27] = gengetopt_args_info_detailed_help[27];
  gengetopt_args_info_full_help[28] = gengetopt_args_info_detailed_help[28];
  gengetopt_args_info_full_help[29] = gengetopt_args_info_detailed_help[29];
  gengetopt_args_info_full_help[30] = gengetopt_args_info_detailed_help[30];
  gengetopt_args_info_full_help[31] = gengetopt_args_info_detailed_help[31];
  gengetopt_args_info_full_help[32] = gengetopt_args_info_detailed_help[32];
  gengetopt_args_info_full_help[33] = gengetopt_args_info_detailed_help[33];
  gengetopt_args_info_full_help[34] = gengetopt_args_info_detailed_help[34];
  gengetopt_args_info_full_help[35] = gengetopt_args_info_detailed_help[35];
  gengetopt_args_info_full_help[36] = gengetopt_args_info_detailed_help[36];
  gengetopt_args_info_full_help[37] = gengetopt_args_info_detailed_help[37];
  gengetopt_args_info_full_help[38] = gengetopt_args_info_detailed_help[38];
  gengetopt_args_info_full_help[39] = gengetopt_args_info_detailed_help[40];
  gengetopt_args_info_full_help[40] = gengetopt_args_info_detailed_help[41];
  gengetopt_args_info_full_help[41] = gengetopt_args_info_detailed_help[42];
  gengetopt_args_info_full_help[42] = gengetopt_args_info_detailed_help[43];
  gengetopt_args_info_full_help[43] = gengetopt_args_info_detailed_help[44];
  gengetopt_args_info_full_help[44] = gengetopt_args_info_detailed_help[45];
  gengetopt_args_info_full_help[45] = gengetopt_args_info_detailed_help[46];
  gengetopt_args_info_full_help[46] = gengetopt_args_info_detailed_help[47];
  gengetopt_args_info_full_help[47] = gengetopt_args_info_detailed_help[48];
  gengetopt_args_info_full_help[48] = gengetopt_args_info_detailed_help[49];
  gengetopt_args_info_full_help[49] = gengetopt_args_info_detailed_help[50];
  gengetopt_args_info_full_help[50] = gengetopt_args_info_detailed_help[51];
  gengetopt_args_info_full_help[51] = gengetopt_args_info_detailed_help[52];
  gengetopt_args_info_full_help[52] = gengetopt_args_info_detailed_help[53];
  gengetopt_args_info_full_help[53] = gengetopt_args_info_detailed_help[54];
  gengetopt_args_info_full_help[54] = gengetopt_args_info_detailed_help[55];
  gengetopt_args_info_full_help[55] = gengetopt_args_info_detailed_help[56];
  gengetopt_args_info_full_help[56] = gengetopt_args_info_detailed_help[57];
  gengetopt_args_info_full_help[57] = gengetopt_args_info_detailed_help[58];
  gengetopt_args_info_full_help[58] = gengetopt_args_info_detailed_help[59];
  gengetopt_args_info_full_help[59] = gengetopt_args_info_detailed_help[60];
  gengetopt_args_info_full_help[60] = gengetopt_args_info_detailed_help[61];
  gengetopt_args_info_full_help[61] = gengetopt_args_info_detailed_help[62];
  gengetopt_args_info_full_help[62] = gengetopt_args_info_detailed_help[63];
  gengetopt_args_info_full_help[63] = gengetopt_args_info_detailed_help[64];
  gengetopt_args_info_full_help[64] = gengetopt_args_info_detailed_help[65];
  gengetopt_args_info_full_help[65] = gengetopt_args_info_detailed_help[66];
  gengetopt_args_info_full_help[66] = gengetopt_args_info_detailed_help[67];
  gengetopt_args_info_full_help[67] = gengetopt_args_info_detailed_help[68];
  gengetopt_args_info_full_help[68] = gengetopt_args_info_detailed_help[69];
  gengetopt_args_info_full_help[69] = gengetopt_args_info_detailed_help[70];
  gengetopt_args_info_full_help[70] = gengetopt_args_info_detailed_help[71];
  gengetopt_args_info_full_help[71] = gengetopt_args_info_detailed_help[72];
  gengetopt_args_info_full_help[72] = gengetopt_args_info_detailed_help[73];
  gengetopt_args_info_full_help[73] = gengetopt_args_info_detailed_help[74];
  gengetopt_args_info_full_help[74] = gengetopt_args_info_detailed_help[75];
  gengetopt_args_info_full_help[75] = gengetopt_args_info_detailed_help[76];
  gengetopt_args_info_full_help[76] = gengetopt_args_info_detailed_help[77];
  gengetopt_args_info_full_help[77] = gengetopt_args_info_detailed_help[78];
  gengetopt_args_info_full_help[78] = gengetopt_args_info_detailed_help[79];
  gengetopt_args_info_full_help[79] = gengetopt_args_info_detailed_help[80];
  gengetopt_args_info_full_help[80] = gengetopt_args_info_detailed_help[81];
  gengetopt_args_info_full_help[81] = gengetopt_args_info_detailed_help[82];
  gengetopt_args_info_full_help[82] = gengetopt_args_info_detailed_help[83];
  gengetopt_args_info_full_help[83] = gengetopt_args_info_detailed_help[84];
  gengetopt_args_info_full_help[84] = gengetopt_args_info_detailed_help[85];
  gengetopt_args_info_full_help[85] = gengetopt_args_info_detailed_help[86];
  gengetopt_args_info_full_help[86] = gengetopt_args_info_detailed_help[87];
  gengetopt_args_info_full_help[87] = gengetopt_args_info_detailed_help[88];
  gengetopt_args_info_full_help[88] = gengetopt_args_info_detailed_help[89];
  gengetopt_args_info_full_help[89] = gengetopt_args_info_detailed_help[90];
  gengetopt_args_info_full_help[90] = gengetopt_args_info_detailed_help[91];
  gengetopt_args_info_full_help[91] = gengetopt_args_info_detailed_help[92];
  gengetopt_args_info_full_help[92] = gengetopt_args_info_detailed_help[93];
  gengetopt_args_info_full_help[93] = gengetopt_args_info_detailed_help[94];
  gengetopt_args_info_full_help[94] = gengetopt_args_info_detailed_help[95];
  gengetopt_args_info_full_help[95] = gengetopt_args_info_detailed_help[96];
  gengetopt_args_info_full_help[96] = gengetopt_args_info_detailed_help[97];
  gengetopt_args_info_full_help[97] = gengetopt_args_info_detailed_help[98];
  gengetopt_args_info_full_help[98] = gengetopt_args_info_detailed_help[99];
  gengetopt_args_info_full_help[99] = gengetopt_args_info_detailed_help[100];
  gengetopt_args_info_full_help[100] = 0; 
  
}

const char *gengetopt_args_info_full_help[101];

static void
init_help_array(void)
{
  gengetopt_args_info_help[0] = gengetopt_args_info_detailed_help[0];
  gengetopt_args_info_help[1] = gengetopt_args_info_detailed_help[1];
  gengetopt_args_info_help[2] = gengetopt_args_info_detailed_help[2];
  gengetopt_args_info_help[3] = gengetopt_args_info_detailed_help[3];
  gengetopt_args_info_help[4] = gengetopt_args_info_detailed_help[4];
  gengetopt_args_info_help[5] = gengetopt_args_info_detailed_help[5];
  gengetopt_args_info_help[6] = gengetopt_args_info_detailed_help[6];
  gengetopt_args_info_help[7] = gengetopt_args_info_detailed_help[7];
  gengetopt_args_info_help[8] = gengetopt_args_info_detailed_help[8];
  gengetopt_args_info_help[9] = gengetopt_args_info_detailed_help[9];
  gengetopt_args_info_help[10] = gengetopt_args_info_detailed_help[10];
  gengetopt_args_info_help[11] = gengetopt_args_info_detailed_help[11];
  gengetopt_args_info_help[12] = gengetopt_args_info_detailed_help[12];
  gengetopt_args_info_help[13] = gengetopt_args_info_detailed_help[13];
  gengetopt_args_info_help[14] = gengetopt_args_info_detailed_help[14];
  gengetopt_args_info_help[15] = gengetopt_args_info_detailed_help[15];
  gengetopt_args_info_help[16] = gengetopt_args_info_detailed_help[16];
  gengetopt_args_info_help[17] = gengetopt_args_info_detailed_help[17];
  gengetopt_args_info_help[18] = gengetopt_args_info_detailed_help[18];
  gengetopt_args_info_help[19] = gengetopt_args_info_detailed_help[19];
  gengetopt_args_info_help[20] = gengetopt_args_info_detailed_help[20];
  gengetopt_args_info_help[21] = gengetopt_args_info_detailed_help[21];
  gengetopt_args_info_help[22] = gengetopt_args_info_detailed_help[22];
  gengetopt_args_info_help[23] = gengetopt_args_info_detailed_help[23];
  gengetopt_args_info_help[24] = gengetopt_args_info_detailed_help[24];
  gengetopt_args_info_help[25] = gengetopt_args_info_detailed_help[25];
  gengetopt_args_info_help[26] = gengetopt_args_info_detailed_help[26];
  gengetopt_args_info_help[27] = gengetopt_args_info_detailed_help[27];
  gengetopt_args_info_help[28] = gengetopt_args_info_detailed_help[28];
  gengetopt_args_info_help[29] = gengetopt_args_info_detailed_help[29];
  gengetopt_args_info_help[30] = gengetopt_args_info_detailed_help[30];
  gengetopt_args_info_help[31] = gengetopt_args_info_detailed_help[31];
  gengetopt_args_info_help[32] = gengetopt_args_info_detailed_help[32];
  gengetopt_args_info_help[33] = gengetopt_args_info_detailed_help[33];
  gengetopt_args_info_help[34] = gengetopt_args_info_detailed_help[34];
  gengetopt_args_info_help[35] = gengetopt_args_info_detailed_help[35];
  gengetopt_args_info_help[36] = gengetopt_args_info_detailed_help[36];
  gengetopt_args_info_help[37] = gengetopt_args_info_detailed_help[37];
  gengetopt_args_info_help[38] = gengetopt_args_info_detailed_help[38];
  gengetopt_args_info_help[39] = gengetopt_args_info_detailed_help[40];
  gengetopt_args_info_help[40] = gengetopt_args_info_detailed_help[41];
  gengetopt_args_info_help[41] = gengetopt_args_info_detailed_help[42];
  gengetopt_args_info_help[42] = gengetopt_args_info_detailed_help[43];
  gengetopt_args_info_help[43] = gengetopt_args_info_detailed_help[44];
  gengetopt_args_info_help[44] = gengetopt_args_info_detailed_help[45];
  gengetopt_args_info_help[45] = gengetopt_args_info_detailed_help[46];
  gengetopt_args_info_help[46] = gengetopt_args_info_detailed_help[47];
  gengetopt_args_info_help[47] = gengetopt_args_info_detailed_help[48];
  gengetopt_args_info_help[48] = gengetopt_args_info_detailed_help[49];
  gengetopt_args_info_help[49] = gengetopt_args_info_detailed_help[50];
  gengetopt_args_info_help[50] = gengetopt_args_info_detailed_help[51];
  gengetopt_args_info_help[51] = gengetopt_args_info_detailed_help[52];
  gengetopt_args_info_help[52] = gengetopt_args_info_detailed_help[53];
  gengetopt_args_info_help[53] = gengetopt_args_info_detailed_help[54];
  gengetopt_args_info_help[54] = gengetopt_args_info_detailed_help[55];
  gengetopt_args_info_help[55] = gengetopt_args_info_detailed_help[56];
  gengetopt_args_info_help[56] = gengetopt_args_info_detailed_help[57];
  gengetopt_args_info_help[57] = gengetopt_args_info_detailed_help[58];
  gengetopt_args_info_help[58] = gengetopt_args_info_detailed_help[59];
  gengetopt_args_info_help[59] = gengetopt_args_info_detailed_help[60];
  gengetopt_args_info_help[60] = gengetopt_args_info_detailed_help[61];
  gengetopt_args_info_help[61] = gengetopt_args_info_detailed_help[62];
  gengetopt_args_info_help[62] = gengetopt_args_info_detailed_help[63];
  gengetopt_args_info_help[63] = gengetopt_args_info_detailed_help[64];
  gengetopt_args_info_help[64] = gengetopt_args_info_detailed_help[65];
  gengetopt_args_info_help[65] = gengetopt_args_info_detailed_help[66];
  gengetopt_args_info_help[66] = gengetopt_args_info_detailed_help[67];
  gengetopt_args_info_help[67] = gengetopt_args_info_detailed_help[69];
  gengetopt_args_info_help[68] = gengetopt_args_info_detailed_help[70];
  gengetopt_args_info_help[69] = gengetopt_args_info_detailed_help[71];
  gengetopt_args_info_help[70] = gengetopt_args_info_detailed_help[72];
  gengetopt_args_info_help[71] = gengetopt_args_info_detailed_help[73];
  gengetopt_args_info_help[72] = gengetopt_args_info_detailed_help[74];
  gengetopt_args_info_help[73] = gengetopt_args_info_detailed_help[75];
  gengetopt_args_info_help[74] = gengetopt_args_info_detailed_help[76];
  gengetopt_args_info_help[75] = gengetopt_args_info_detailed_help[77];
  gengetopt_args_info_help[76] = gengetopt_args_info_detailed_help[78];
  gengetopt_args_info_help[77] = gengetopt_args_info_detailed_help[79];
  gengetopt_args_info_help[78] = gengetopt_args_info_detailed_help[80];
  gengetopt_args_info_help[79] = gengetopt_args_info_detailed_help[81];
  gengetopt_args_info_help[80] = gengetopt_args_info_detailed_help[82];
  gengetopt_args_info_help[81] = gengetopt_args_info_detailed_help[83];
  gengetopt_args_info_help[82] = gengetopt_args_info_detailed_help[84];
  gengetopt_args_info_help[83] = gengetopt_args_info_detailed_help[85];
  gengetopt_args_info_help[84] = gengetopt_args_info_detailed_help[86];
  gengetopt_args_info_help[85] = gengetopt_args_info_detailed_help[87];
  gengetopt_args_info_help[86] = gengetopt_args_info_detailed_help[88];
  gengetopt_args_info_help[87] = gengetopt_args_info_detailed_help[89];
  gengetopt_args_info_help[88] = gengetopt_args_info_detailed_help[90];
  gengetopt_args_info_help[89] = gengetopt_args_info_detailed_help[91];
  gengetopt_args_info_help[90] = gengetopt_args_info_detailed_help[92];
  gengetopt_args_info_help[91] = gengetopt_args_info_detailed_help[93];
  gengetopt_args_info_help[92] = gengetopt_args_info_detailed_help[94];
  gengetopt_args_info_help[93] = gengetopt_args_info_detailed_help[95];
  gengetopt_args_info_help[94] = gengetopt_args_info_detailed_help[96];
  gengetopt_args_info_help[95] = gengetopt_args_info_detailed_help[97];
  gengetopt_args_info_help[96] = gengetopt_args_info_detailed_help[98];
  gengetopt_args_info_help[97] = gengetopt_args_info_detailed_help[99];
  gengetopt_args_info_help[98] = gengetopt_args_info_detailed_help[100];
  gengetopt_args_info_help[99] = 0; 
  
}

const char *gengetopt_args_info_help[100];

typedef enum {ARG_NO
  , ARG_FLAG
  , ARG_STRING
  , ARG_LONG
  , ARG_DOUBLE
  , ARG_ENUM
} my_cmdline_parser_arg_type;

static
void clear_given (struct gengetopt_args_info *args_info);
static
void clear_args (struct gengetopt_args_info *args_info);

static int
my_cmdline_parser_internal (int argc, char **argv, struct gengetopt_args_info *args_info,
                        struct my_cmdline_parser_params *params, const char *additional_error);

static int
my_cmdline_parser_required2 (struct gengetopt_args_info *args_info, const char *prog_name, const char *additional_error);

const char *my_cmdline_parser_format_values[] = {"fasta", "fastq", "fa", "fq", "seq", 0}; /*< Possible values for format. */
const char *my_cmdline_parser_loglevel_values[] = {"0", "1", "2", "3", "4", "5", 0}; /*< Possible values for loglevel. */
const char *my_cmdline_parser_select_version_values[] = {"0", "1", "2", "3", 0}; /*< Possible values for select-version. */

static char *
gengetopt_strdup (const char *s);

static
void clear_given (struct gengetopt_args_info *args_info)
{
  args_info->version_given = 0 ;
  args_info->help_given = 0 ;
  args_info->detailed_help_given = 0 ;
  args_info->full_help_given = 0 ;
  args_info->count_given = 0 ;
  args_info->kmer_given = 0 ;
  args_info->disk_given = 0 ;
  args_info->load_disk_given = 0 ;
  args_info->memory_given = 0 ;
  args_info->load_memory_given = 0 ;
  args_info->nthread_given = 0 ;
  args_info->outfile_given = 0 ;
  args_info->outdir_given = 0 ;
  args_info->nh_given = 0 ;
  args_info->no_partition_given = 0 ;
  args_info->no_count_given = 0 ;
  args_info->no_delete_given = 0 ;
  args_info->report_given = 0 ;
  args_info->summary_given = 0 ;
  args_info->fasta_given = 0 ;
  args_info->no_tab_given = 0 ;
  args_info->query_given = 0 ;
  args_info->sequence_given = 0 ;
  args_info->simulate_given = 0 ;
  args_info->maxkmer_given = 0 ;
  args_info->format_given = 0 ;
  args_info->ni_given = 0 ;
  args_info->np_given = 0 ;
  args_info->nf_given = 0 ;
  args_info->seqlen_given = 0 ;
  args_info->seed_given = 0 ;
  args_info->partition_given = 0 ;
  args_info->inbuffer_given = 0 ;
  args_info->outbuffer_given = 0 ;
  args_info->decode_given = 0 ;
  args_info->table_given = 0 ;
  args_info->list_given = 0 ;
  args_info->match_given = 0 ;
  args_info->tabfile_given = 0 ;
  args_info->binary_given = 0 ;
  args_info->uncompress_given = 0 ;
  args_info->inspect_given = 0 ;
  args_info->cite_given = 0 ;
  args_info->log_given = 0 ;
  args_info->progress_given = 0 ;
  args_info->loglevel_given = 0 ;
  args_info->progress_to_stderr_given = 0 ;
  args_info->totalmaxkmer_given = 0 ;
  args_info->select_version_given = 0 ;
  args_info->bin_outdir_given = 0 ;
  args_info->par_outdir_given = 0 ;
  args_info->tab_outdir_given = 0 ;
  args_info->mer_len_given = 0 ;
  args_info->canonical_given = 0 ;
  args_info->lower_count_given = 0 ;
  args_info->upper_count_given = 0 ;
  args_info->size_given = 0 ;
  args_info->threads_given = 0 ;
  args_info->output_given = 0 ;
  args_info->with_reverse_given = 0 ;
  args_info->with_index_given = 0 ;
  args_info->only_init_given = 0 ;
  args_info->with_parfile_given = 0 ;
  args_info->min_table_memory_given = 0 ;
  args_info->max_table_memory_given = 0 ;
  args_info->release_given = 0 ;
  args_info->exit_given = 0 ;
  args_info->examples_given = 0 ;
  args_info->document_given = 0 ;
}

static
void clear_args (struct gengetopt_args_info *args_info)
{
  FIX_UNUSED (args_info);
  args_info->help_flag = 0;
  args_info->detailed_help_flag = 0;
  args_info->full_help_flag = 0;
  args_info->count_flag = 0;
  args_info->kmer_arg = 1;
  args_info->kmer_orig = NULL;
  args_info->disk_arg = 10;
  args_info->disk_orig = NULL;
  args_info->load_disk_arg = 1.0;
  args_info->load_disk_orig = NULL;
  args_info->memory_arg = 10;
  args_info->memory_orig = NULL;
  args_info->load_memory_arg = 1.0;
  args_info->load_memory_orig = NULL;
  args_info->nthread_arg = 1;
  args_info->nthread_orig = NULL;
  args_info->outfile_arg = gengetopt_strdup ("outfile");
  args_info->outfile_orig = NULL;
  args_info->outdir_arg = gengetopt_strdup (".");
  args_info->outdir_orig = NULL;
  args_info->nh_arg = 10;
  args_info->nh_orig = NULL;
  args_info->no_partition_flag = 0;
  args_info->no_count_flag = 0;
  args_info->no_delete_flag = 0;
  args_info->report_flag = 0;
  args_info->summary_flag = 0;
  args_info->fasta_flag = 0;
  args_info->no_tab_flag = 0;
  args_info->query_flag = 0;
  args_info->sequence_arg = NULL;
  args_info->sequence_orig = NULL;
  args_info->simulate_flag = 0;
  args_info->maxkmer_arg = 1000;
  args_info->maxkmer_orig = NULL;
  args_info->format_arg = format_arg_fastq;
  args_info->format_orig = NULL;
  args_info->ni_arg = 1;
  args_info->ni_orig = NULL;
  args_info->np_arg = 1;
  args_info->np_orig = NULL;
  args_info->nf_arg = 1;
  args_info->nf_orig = NULL;
  args_info->seqlen_arg = 100;
  args_info->seqlen_orig = NULL;
  args_info->seed_arg = -1;
  args_info->seed_orig = NULL;
  args_info->partition_flag = 0;
  args_info->inbuffer_arg = 0;
  args_info->inbuffer_orig = NULL;
  args_info->outbuffer_arg = 0;
  args_info->outbuffer_orig = NULL;
  args_info->decode_flag = 0;
  args_info->table_flag = 0;
  args_info->list_flag = 0;
  args_info->match_flag = 0;
  args_info->tabfile_arg = gengetopt_strdup ("outfile.tbl");
  args_info->tabfile_orig = NULL;
  args_info->binary_flag = 0;
  args_info->uncompress_flag = 0;
  args_info->inspect_flag = 0;
  args_info->log_arg = gengetopt_strdup ("outfile.log");
  args_info->log_orig = NULL;
  args_info->progress_flag = 0;
  args_info->loglevel_arg = 1;
  args_info->loglevel_orig = NULL;
  args_info->progress_to_stderr_flag = 0;
  args_info->totalmaxkmer_arg = 0;
  args_info->totalmaxkmer_orig = NULL;
  args_info->select_version_arg = 0;
  args_info->select_version_orig = NULL;
  args_info->bin_outdir_arg = gengetopt_strdup (".");
  args_info->bin_outdir_orig = NULL;
  args_info->par_outdir_arg = gengetopt_strdup (".");
  args_info->par_outdir_orig = NULL;
  args_info->tab_outdir_arg = gengetopt_strdup (".");
  args_info->tab_outdir_orig = NULL;
  args_info->mer_len_arg = 1;
  args_info->mer_len_orig = NULL;
  args_info->canonical_flag = 0;
  args_info->lower_count_arg = 1;
  args_info->lower_count_orig = NULL;
  args_info->upper_count_arg = 65535;
  args_info->upper_count_orig = NULL;
  args_info->size_arg = 1;
  args_info->size_orig = NULL;
  args_info->threads_arg = 1;
  args_info->threads_orig = NULL;
  args_info->output_arg = gengetopt_strdup ("outfile");
  args_info->output_orig = NULL;
  args_info->with_reverse_flag = 0;
  args_info->with_index_flag = 0;
  args_info->only_init_flag = 0;
  args_info->with_parfile_flag = 0;
  args_info->min_table_memory_arg = 100;
  args_info->min_table_memory_orig = NULL;
  args_info->max_table_memory_arg = 1000;
  args_info->max_table_memory_orig = NULL;
  args_info->release_flag = 1;
  args_info->exit_flag = 0;
  args_info->examples_flag = 0;
  args_info->document_flag = 0;
  
}

static
void init_args_info(struct gengetopt_args_info *args_info)
{
  init_full_help_array(); 
  init_help_array(); 
  args_info->version_help = gengetopt_args_info_detailed_help[0] ;
  args_info->help_help = gengetopt_args_info_detailed_help[1] ;
  args_info->detailed_help_help = gengetopt_args_info_detailed_help[2] ;
  args_info->full_help_help = gengetopt_args_info_detailed_help[3] ;
  args_info->count_help = gengetopt_args_info_detailed_help[6] ;
  args_info->kmer_help = gengetopt_args_info_detailed_help[7] ;
  args_info->disk_help = gengetopt_args_info_detailed_help[8] ;
  args_info->load_disk_help = gengetopt_args_info_detailed_help[9] ;
  args_info->memory_help = gengetopt_args_info_detailed_help[10] ;
  args_info->load_memory_help = gengetopt_args_info_detailed_help[11] ;
  args_info->nthread_help = gengetopt_args_info_detailed_help[12] ;
  args_info->outfile_help = gengetopt_args_info_detailed_help[13] ;
  args_info->outdir_help = gengetopt_args_info_detailed_help[14] ;
  args_info->nh_help = gengetopt_args_info_detailed_help[15] ;
  args_info->no_partition_help = gengetopt_args_info_detailed_help[16] ;
  args_info->no_count_help = gengetopt_args_info_detailed_help[17] ;
  args_info->no_delete_help = gengetopt_args_info_detailed_help[18] ;
  args_info->report_help = gengetopt_args_info_detailed_help[21] ;
  args_info->summary_help = gengetopt_args_info_detailed_help[22] ;
  args_info->fasta_help = gengetopt_args_info_detailed_help[23] ;
  args_info->no_tab_help = gengetopt_args_info_detailed_help[24] ;
  args_info->query_help = gengetopt_args_info_detailed_help[27] ;
  args_info->sequence_help = gengetopt_args_info_detailed_help[28] ;
  args_info->simulate_help = gengetopt_args_info_detailed_help[31] ;
  args_info->maxkmer_help = gengetopt_args_info_detailed_help[32] ;
  args_info->format_help = gengetopt_args_info_detailed_help[33] ;
  args_info->ni_help = gengetopt_args_info_detailed_help[34] ;
  args_info->np_help = gengetopt_args_info_detailed_help[35] ;
  args_info->nf_help = gengetopt_args_info_detailed_help[36] ;
  args_info->seqlen_help = gengetopt_args_info_detailed_help[37] ;
  args_info->seed_help = gengetopt_args_info_detailed_help[38] ;
  args_info->partition_help = gengetopt_args_info_detailed_help[42] ;
  args_info->inbuffer_help = gengetopt_args_info_detailed_help[43] ;
  args_info->outbuffer_help = gengetopt_args_info_detailed_help[44] ;
  args_info->decode_help = gengetopt_args_info_detailed_help[47] ;
  args_info->table_help = gengetopt_args_info_detailed_help[50] ;
  args_info->list_help = gengetopt_args_info_detailed_help[53] ;
  args_info->match_help = gengetopt_args_info_detailed_help[56] ;
  args_info->tabfile_help = gengetopt_args_info_detailed_help[57] ;
  args_info->binary_help = gengetopt_args_info_detailed_help[60] ;
  args_info->uncompress_help = gengetopt_args_info_detailed_help[63] ;
  args_info->inspect_help = gengetopt_args_info_detailed_help[66] ;
  args_info->cite_help = gengetopt_args_info_detailed_help[68] ;
  args_info->log_help = gengetopt_args_info_detailed_help[69] ;
  args_info->progress_help = gengetopt_args_info_detailed_help[70] ;
  args_info->loglevel_help = gengetopt_args_info_detailed_help[71] ;
  args_info->progress_to_stderr_help = gengetopt_args_info_detailed_help[72] ;
  args_info->totalmaxkmer_help = gengetopt_args_info_detailed_help[73] ;
  args_info->select_version_help = gengetopt_args_info_detailed_help[74] ;
  args_info->bin_outdir_help = gengetopt_args_info_detailed_help[75] ;
  args_info->par_outdir_help = gengetopt_args_info_detailed_help[76] ;
  args_info->tab_outdir_help = gengetopt_args_info_detailed_help[77] ;
  args_info->mer_len_help = gengetopt_args_info_detailed_help[78] ;
  args_info->canonical_help = gengetopt_args_info_detailed_help[79] ;
  args_info->lower_count_help = gengetopt_args_info_detailed_help[80] ;
  args_info->upper_count_help = gengetopt_args_info_detailed_help[81] ;
  args_info->size_help = gengetopt_args_info_detailed_help[82] ;
  args_info->threads_help = gengetopt_args_info_detailed_help[83] ;
  args_info->output_help = gengetopt_args_info_detailed_help[84] ;
  args_info->with_reverse_help = gengetopt_args_info_detailed_help[85] ;
  args_info->with_index_help = gengetopt_args_info_detailed_help[86] ;
  args_info->only_init_help = gengetopt_args_info_detailed_help[87] ;
  args_info->with_parfile_help = gengetopt_args_info_detailed_help[88] ;
  args_info->min_table_memory_help = gengetopt_args_info_detailed_help[89] ;
  args_info->max_table_memory_help = gengetopt_args_info_detailed_help[90] ;
  args_info->release_help = gengetopt_args_info_detailed_help[91] ;
  args_info->exit_help = gengetopt_args_info_detailed_help[94] ;
  args_info->examples_help = gengetopt_args_info_detailed_help[97] ;
  args_info->document_help = gengetopt_args_info_detailed_help[100] ;
  
}

void
my_cmdline_parser_print_version (void)
{
  printf ("%s %s\n",
     (strlen(MY_CMDLINE_PARSER_PACKAGE_NAME) ? MY_CMDLINE_PARSER_PACKAGE_NAME : MY_CMDLINE_PARSER_PACKAGE),
     MY_CMDLINE_PARSER_VERSION);

  if (strlen(gengetopt_args_info_versiontext) > 0)
    printf("\n%s\n", gengetopt_args_info_versiontext);
}

static void print_help_common(void) {
  my_cmdline_parser_print_version ();

  if (strlen(gengetopt_args_info_purpose) > 0)
    printf("\n%s\n", gengetopt_args_info_purpose);

  if (strlen(gengetopt_args_info_usage) > 0)
    printf("\n%s\n", gengetopt_args_info_usage);

  printf("\n");

  if (strlen(gengetopt_args_info_description) > 0)
    printf("%s\n\n", gengetopt_args_info_description);
}

void
my_cmdline_parser_print_help (void)
{
  int i = 0;
  print_help_common();
  while (gengetopt_args_info_help[i])
    printf("%s\n", gengetopt_args_info_help[i++]);
}

void
my_cmdline_parser_print_full_help (void)
{
  int i = 0;
  print_help_common();
  while (gengetopt_args_info_full_help[i])
    printf("%s\n", gengetopt_args_info_full_help[i++]);
}

void
my_cmdline_parser_print_detailed_help (void)
{
  int i = 0;
  print_help_common();
  while (gengetopt_args_info_detailed_help[i])
    printf("%s\n", gengetopt_args_info_detailed_help[i++]);
}

void
my_cmdline_parser_init (struct gengetopt_args_info *args_info)
{
  clear_given (args_info);
  clear_args (args_info);
  init_args_info (args_info);

  args_info->inputs = 0;
  args_info->inputs_num = 0;
}

void
my_cmdline_parser_params_init(struct my_cmdline_parser_params *params)
{
  if (params)
    { 
      params->override = 0;
      params->initialize = 1;
      params->check_required = 1;
      params->check_ambiguity = 0;
      params->print_errors = 1;
    }
}

struct my_cmdline_parser_params *
my_cmdline_parser_params_create(void)
{
  struct my_cmdline_parser_params *params = 
    (struct my_cmdline_parser_params *)malloc(sizeof(struct my_cmdline_parser_params));
  my_cmdline_parser_params_init(params);  
  return params;
}

static void
free_string_field (char **s)
{
  if (*s)
    {
      free (*s);
      *s = 0;
    }
}


static void
my_cmdline_parser_release (struct gengetopt_args_info *args_info)
{
  unsigned int i;
  free_string_field (&(args_info->kmer_orig));
  free_string_field (&(args_info->disk_orig));
  free_string_field (&(args_info->load_disk_orig));
  free_string_field (&(args_info->memory_orig));
  free_string_field (&(args_info->load_memory_orig));
  free_string_field (&(args_info->nthread_orig));
  free_string_field (&(args_info->outfile_arg));
  free_string_field (&(args_info->outfile_orig));
  free_string_field (&(args_info->outdir_arg));
  free_string_field (&(args_info->outdir_orig));
  free_string_field (&(args_info->nh_orig));
  free_string_field (&(args_info->sequence_arg));
  free_string_field (&(args_info->sequence_orig));
  free_string_field (&(args_info->maxkmer_orig));
  free_string_field (&(args_info->format_orig));
  free_string_field (&(args_info->ni_orig));
  free_string_field (&(args_info->np_orig));
  free_string_field (&(args_info->nf_orig));
  free_string_field (&(args_info->seqlen_orig));
  free_string_field (&(args_info->seed_orig));
  free_string_field (&(args_info->inbuffer_orig));
  free_string_field (&(args_info->outbuffer_orig));
  free_string_field (&(args_info->tabfile_arg));
  free_string_field (&(args_info->tabfile_orig));
  free_string_field (&(args_info->log_arg));
  free_string_field (&(args_info->log_orig));
  free_string_field (&(args_info->loglevel_orig));
  free_string_field (&(args_info->totalmaxkmer_orig));
  free_string_field (&(args_info->select_version_orig));
  free_string_field (&(args_info->bin_outdir_arg));
  free_string_field (&(args_info->bin_outdir_orig));
  free_string_field (&(args_info->par_outdir_arg));
  free_string_field (&(args_info->par_outdir_orig));
  free_string_field (&(args_info->tab_outdir_arg));
  free_string_field (&(args_info->tab_outdir_orig));
  free_string_field (&(args_info->mer_len_orig));
  free_string_field (&(args_info->lower_count_orig));
  free_string_field (&(args_info->upper_count_orig));
  free_string_field (&(args_info->size_orig));
  free_string_field (&(args_info->threads_orig));
  free_string_field (&(args_info->output_arg));
  free_string_field (&(args_info->output_orig));
  free_string_field (&(args_info->min_table_memory_orig));
  free_string_field (&(args_info->max_table_memory_orig));
  
  
  for (i = 0; i < args_info->inputs_num; ++i)
    free (args_info->inputs [i]);

  if (args_info->inputs_num)
    free (args_info->inputs);

  clear_given (args_info);
}

/**
 * @param val the value to check
 * @param values the possible values
 * @return the index of the matched value:
 * -1 if no value matched,
 * -2 if more than one value has matched
 */
static int
check_possible_values(const char *val, const char *values[])
{
  int i, found, last;
  size_t len;

  if (!val)   /* otherwise strlen() crashes below */
    return -1; /* -1 means no argument for the option */

  found = last = 0;

  for (i = 0, len = strlen(val); values[i]; ++i)
    {
      if (strncmp(val, values[i], len) == 0)
        {
          ++found;
          last = i;
          if (strlen(values[i]) == len)
            return i; /* exact macth no need to check more */
        }
    }

  if (found == 1) /* one match: OK */
    return last;

  return (found ? -2 : -1); /* return many values or none matched */
}


static void
write_into_file(FILE *outfile, const char *opt, const char *arg, const char *values[])
{
  int found = -1;
  if (arg) {
    if (values) {
      found = check_possible_values(arg, values);      
    }
    if (found >= 0)
      fprintf(outfile, "%s=\"%s\" # %s\n", opt, arg, values[found]);
    else
      fprintf(outfile, "%s=\"%s\"\n", opt, arg);
  } else {
    fprintf(outfile, "%s\n", opt);
  }
}


int
my_cmdline_parser_dump(FILE *outfile, struct gengetopt_args_info *args_info)
{
  int i = 0;

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot dump options to stream\n", MY_CMDLINE_PARSER_PACKAGE);
      return EXIT_FAILURE;
    }

  if (args_info->version_given)
    write_into_file(outfile, "version", 0, 0 );
  if (args_info->help_given)
    write_into_file(outfile, "help", 0, 0 );
  if (args_info->detailed_help_given)
    write_into_file(outfile, "detailed-help", 0, 0 );
  if (args_info->full_help_given)
    write_into_file(outfile, "full-help", 0, 0 );
  if (args_info->count_given)
    write_into_file(outfile, "count", 0, 0 );
  if (args_info->kmer_given)
    write_into_file(outfile, "kmer", args_info->kmer_orig, 0);
  if (args_info->disk_given)
    write_into_file(outfile, "disk", args_info->disk_orig, 0);
  if (args_info->load_disk_given)
    write_into_file(outfile, "load-disk", args_info->load_disk_orig, 0);
  if (args_info->memory_given)
    write_into_file(outfile, "memory", args_info->memory_orig, 0);
  if (args_info->load_memory_given)
    write_into_file(outfile, "load-memory", args_info->load_memory_orig, 0);
  if (args_info->nthread_given)
    write_into_file(outfile, "nthread", args_info->nthread_orig, 0);
  if (args_info->outfile_given)
    write_into_file(outfile, "outfile", args_info->outfile_orig, 0);
  if (args_info->outdir_given)
    write_into_file(outfile, "outdir", args_info->outdir_orig, 0);
  if (args_info->nh_given)
    write_into_file(outfile, "nh", args_info->nh_orig, 0);
  if (args_info->no_partition_given)
    write_into_file(outfile, "no-partition", 0, 0 );
  if (args_info->no_count_given)
    write_into_file(outfile, "no-count", 0, 0 );
  if (args_info->no_delete_given)
    write_into_file(outfile, "no-delete", 0, 0 );
  if (args_info->report_given)
    write_into_file(outfile, "report", 0, 0 );
  if (args_info->summary_given)
    write_into_file(outfile, "summary", 0, 0 );
  if (args_info->fasta_given)
    write_into_file(outfile, "fasta", 0, 0 );
  if (args_info->no_tab_given)
    write_into_file(outfile, "no-tab", 0, 0 );
  if (args_info->query_given)
    write_into_file(outfile, "query", 0, 0 );
  if (args_info->sequence_given)
    write_into_file(outfile, "sequence", args_info->sequence_orig, 0);
  if (args_info->simulate_given)
    write_into_file(outfile, "simulate", 0, 0 );
  if (args_info->maxkmer_given)
    write_into_file(outfile, "maxkmer", args_info->maxkmer_orig, 0);
  if (args_info->format_given)
    write_into_file(outfile, "format", args_info->format_orig, my_cmdline_parser_format_values);
  if (args_info->ni_given)
    write_into_file(outfile, "ni", args_info->ni_orig, 0);
  if (args_info->np_given)
    write_into_file(outfile, "np", args_info->np_orig, 0);
  if (args_info->nf_given)
    write_into_file(outfile, "nf", args_info->nf_orig, 0);
  if (args_info->seqlen_given)
    write_into_file(outfile, "seqlen", args_info->seqlen_orig, 0);
  if (args_info->seed_given)
    write_into_file(outfile, "seed", args_info->seed_orig, 0);
  if (args_info->partition_given)
    write_into_file(outfile, "partition", 0, 0 );
  if (args_info->inbuffer_given)
    write_into_file(outfile, "inbuffer", args_info->inbuffer_orig, 0);
  if (args_info->outbuffer_given)
    write_into_file(outfile, "outbuffer", args_info->outbuffer_orig, 0);
  if (args_info->decode_given)
    write_into_file(outfile, "decode", 0, 0 );
  if (args_info->table_given)
    write_into_file(outfile, "table", 0, 0 );
  if (args_info->list_given)
    write_into_file(outfile, "list", 0, 0 );
  if (args_info->match_given)
    write_into_file(outfile, "match", 0, 0 );
  if (args_info->tabfile_given)
    write_into_file(outfile, "tabfile", args_info->tabfile_orig, 0);
  if (args_info->binary_given)
    write_into_file(outfile, "binary", 0, 0 );
  if (args_info->uncompress_given)
    write_into_file(outfile, "uncompress", 0, 0 );
  if (args_info->inspect_given)
    write_into_file(outfile, "inspect", 0, 0 );
  if (args_info->cite_given)
    write_into_file(outfile, "cite", 0, 0 );
  if (args_info->log_given)
    write_into_file(outfile, "log", args_info->log_orig, 0);
  if (args_info->progress_given)
    write_into_file(outfile, "progress", 0, 0 );
  if (args_info->loglevel_given)
    write_into_file(outfile, "loglevel", args_info->loglevel_orig, my_cmdline_parser_loglevel_values);
  if (args_info->progress_to_stderr_given)
    write_into_file(outfile, "progress-to-stderr", 0, 0 );
  if (args_info->totalmaxkmer_given)
    write_into_file(outfile, "totalmaxkmer", args_info->totalmaxkmer_orig, 0);
  if (args_info->select_version_given)
    write_into_file(outfile, "select-version", args_info->select_version_orig, my_cmdline_parser_select_version_values);
  if (args_info->bin_outdir_given)
    write_into_file(outfile, "bin-outdir", args_info->bin_outdir_orig, 0);
  if (args_info->par_outdir_given)
    write_into_file(outfile, "par-outdir", args_info->par_outdir_orig, 0);
  if (args_info->tab_outdir_given)
    write_into_file(outfile, "tab-outdir", args_info->tab_outdir_orig, 0);
  if (args_info->mer_len_given)
    write_into_file(outfile, "mer-len", args_info->mer_len_orig, 0);
  if (args_info->canonical_given)
    write_into_file(outfile, "canonical", 0, 0 );
  if (args_info->lower_count_given)
    write_into_file(outfile, "lower-count", args_info->lower_count_orig, 0);
  if (args_info->upper_count_given)
    write_into_file(outfile, "upper-count", args_info->upper_count_orig, 0);
  if (args_info->size_given)
    write_into_file(outfile, "size", args_info->size_orig, 0);
  if (args_info->threads_given)
    write_into_file(outfile, "threads", args_info->threads_orig, 0);
  if (args_info->output_given)
    write_into_file(outfile, "output", args_info->output_orig, 0);
  if (args_info->with_reverse_given)
    write_into_file(outfile, "with-reverse", 0, 0 );
  if (args_info->with_index_given)
    write_into_file(outfile, "with-index", 0, 0 );
  if (args_info->only_init_given)
    write_into_file(outfile, "only-init", 0, 0 );
  if (args_info->with_parfile_given)
    write_into_file(outfile, "with-parfile", 0, 0 );
  if (args_info->min_table_memory_given)
    write_into_file(outfile, "min-table-memory", args_info->min_table_memory_orig, 0);
  if (args_info->max_table_memory_given)
    write_into_file(outfile, "max-table-memory", args_info->max_table_memory_orig, 0);
  if (args_info->release_given)
    write_into_file(outfile, "release", 0, 0 );
  if (args_info->exit_given)
    write_into_file(outfile, "exit", 0, 0 );
  if (args_info->examples_given)
    write_into_file(outfile, "examples", 0, 0 );
  if (args_info->document_given)
    write_into_file(outfile, "document", 0, 0 );
  

  i = EXIT_SUCCESS;
  return i;
}

int
my_cmdline_parser_file_save(const char *filename, struct gengetopt_args_info *args_info)
{
  FILE *outfile;
  int i = 0;

  outfile = fopen(filename, "w");

  if (!outfile)
    {
      fprintf (stderr, "%s: cannot open file for writing: %s\n", MY_CMDLINE_PARSER_PACKAGE, filename);
      return EXIT_FAILURE;
    }

  i = my_cmdline_parser_dump(outfile, args_info);
  fclose (outfile);

  return i;
}

void
my_cmdline_parser_free (struct gengetopt_args_info *args_info)
{
  my_cmdline_parser_release (args_info);
}

/** @brief replacement of strdup, which is not standard */
char *
gengetopt_strdup (const char *s)
{
  char *result = 0;
  if (!s)
    return result;

  result = (char*)malloc(strlen(s) + 1);
  if (result == (char*)0)
    return (char*)0;
  strcpy(result, s);
  return result;
}

int
my_cmdline_parser (int argc, char **argv, struct gengetopt_args_info *args_info)
{
  return my_cmdline_parser2 (argc, argv, args_info, 0, 1, 1);
}

int
my_cmdline_parser_ext (int argc, char **argv, struct gengetopt_args_info *args_info,
                   struct my_cmdline_parser_params *params)
{
  int result;
  result = my_cmdline_parser_internal (argc, argv, args_info, params, 0);

  if (result == EXIT_FAILURE)
    {
      my_cmdline_parser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
my_cmdline_parser2 (int argc, char **argv, struct gengetopt_args_info *args_info, int override, int initialize, int check_required)
{
  int result;
  struct my_cmdline_parser_params params;
  
  params.override = override;
  params.initialize = initialize;
  params.check_required = check_required;
  params.check_ambiguity = 0;
  params.print_errors = 1;

  result = my_cmdline_parser_internal (argc, argv, args_info, &params, 0);

  if (result == EXIT_FAILURE)
    {
      my_cmdline_parser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
my_cmdline_parser_required (struct gengetopt_args_info *args_info, const char *prog_name)
{
  int result = EXIT_SUCCESS;

  if (my_cmdline_parser_required2(args_info, prog_name, 0) > 0)
    result = EXIT_FAILURE;

  if (result == EXIT_FAILURE)
    {
      my_cmdline_parser_free (args_info);
      exit (EXIT_FAILURE);
    }
  
  return result;
}

int
my_cmdline_parser_required2 (struct gengetopt_args_info *args_info, const char *prog_name, const char *additional_error)
{
  int error_occurred = 0;
  FIX_UNUSED (additional_error);

  /* checks for required options */
  
  /* checks for dependences among options */
  if (args_info->partition_given && ! args_info->outfile_given)
    {
      fprintf (stderr, "%s: '--partition' option depends on option 'outfile'%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  if (args_info->decode_given && ! args_info->outfile_given)
    {
      fprintf (stderr, "%s: '--decode' option depends on option 'outfile'%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  if (args_info->table_given && ! args_info->outfile_given)
    {
      fprintf (stderr, "%s: '--table' option depends on option 'outfile'%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }
  if (args_info->loglevel_given && ! args_info->log_given)
    {
      fprintf (stderr, "%s: '--loglevel' option depends on option 'log'%s\n", prog_name, (additional_error ? additional_error : ""));
      error_occurred = 1;
    }

  return error_occurred;
}

/*
 * Extracted from the glibc source tree, version 2.3.6
 *
 * Licensed under the GPL as per the whole glibc source tree.
 *
 * This file was modified so that getopt_long can be called
 * many times without risking previous memory to be spoiled.
 *
 * Modified by Andre Noll and Lorenzo Bettini for use in
 * GNU gengetopt generated files.
 *
 */

/* 
 * we must include anything we need since this file is not thought to be
 * inserted in a file already using getopt.h
 *
 * Lorenzo
 */

struct option
{
  const char *name;
  /* has_arg can't be an enum because some compilers complain about
     type mismatches in all the code that assumes it is an int.  */
  int has_arg;
  int *flag;
  int val;
};

/* This version of `getopt' appears to the caller like standard Unix `getopt'
   but it behaves differently for the user, since it allows the user
   to intersperse the options with the other arguments.

   As `getopt' works, it permutes the elements of ARGV so that,
   when it is done, all the options precede everything else.  Thus
   all application programs are extended to handle flexible argument order.
*/
/*
   If the field `flag' is not NULL, it points to a variable that is set
   to the value given in the field `val' when the option is found, but
   left unchanged if the option is not found.

   To have a long-named option do something other than set an `int' to
   a compiled-in constant, such as set a value from `custom_optarg', set the
   option's `flag' field to zero and its `val' field to a nonzero
   value (the equivalent single-letter option character, if there is
   one).  For long options that have a zero `flag' field, `getopt'
   returns the contents of the `val' field.  */

/* Names for the values of the `has_arg' field of `struct option'.  */
#ifndef no_argument
#define no_argument		0
#endif

#ifndef required_argument
#define required_argument	1
#endif

#ifndef optional_argument
#define optional_argument	2
#endif

struct custom_getopt_data {
	/*
	 * These have exactly the same meaning as the corresponding global variables,
	 * except that they are used for the reentrant versions of getopt.
	 */
	int custom_optind;
	int custom_opterr;
	int custom_optopt;
	char *custom_optarg;

	/* True if the internal members have been initialized.  */
	int initialized;

	/*
	 * The next char to be scanned in the option-element in which the last option
	 * character we returned was found.  This allows us to pick up the scan where
	 * we left off.  If this is zero, or a null string, it means resume the scan by
	 * advancing to the next ARGV-element.
	 */
	char *nextchar;

	/*
	 * Describe the part of ARGV that contains non-options that have been skipped.
	 * `first_nonopt' is the index in ARGV of the first of them; `last_nonopt' is
	 * the index after the last of them.
	 */
	int first_nonopt;
	int last_nonopt;
};

/*
 * the variables optarg, optind, opterr and optopt are renamed with
 * the custom_ prefix so that they don't interfere with getopt ones.
 *
 * Moreover they're static so they are visible only from within the
 * file where this very file will be included.
 */

/*
 * For communication from `custom_getopt' to the caller.  When `custom_getopt' finds an
 * option that takes an argument, the argument value is returned here.
 */
static char *custom_optarg;

/*
 * Index in ARGV of the next element to be scanned.  This is used for
 * communication to and from the caller and for communication between
 * successive calls to `custom_getopt'.
 *
 * On entry to `custom_getopt', 1 means this is the first call; initialize.
 *
 * When `custom_getopt' returns -1, this is the index of the first of the non-option
 * elements that the caller should itself scan.
 *
 * Otherwise, `custom_optind' communicates from one call to the next how much of ARGV
 * has been scanned so far.
 *
 * 1003.2 says this must be 1 before any call.
 */
static int custom_optind = 1;

/*
 * Callers store zero here to inhibit the error message for unrecognized
 * options.
 */
static int custom_opterr = 1;

/*
 * Set to an option character which was unrecognized.  This must be initialized
 * on some systems to avoid linking in the system's own getopt implementation.
 */
static int custom_optopt = '?';

/*
 * Exchange two adjacent subsequences of ARGV.  One subsequence is elements
 * [first_nonopt,last_nonopt) which contains all the non-options that have been
 * skipped so far.  The other is elements [last_nonopt,custom_optind), which contains
 * all the options processed since those non-options were skipped.
 * `first_nonopt' and `last_nonopt' are relocated so that they describe the new
 * indices of the non-options in ARGV after they are moved.
 */
static void exchange(char **argv, struct custom_getopt_data *d)
{
	int bottom = d->first_nonopt;
	int middle = d->last_nonopt;
	int top = d->custom_optind;
	char *tem;

	/*
	 * Exchange the shorter segment with the far end of the longer segment.
	 * That puts the shorter segment into the right place.  It leaves the
	 * longer segment in the right place overall, but it consists of two
	 * parts that need to be swapped next.
	 */
	while (top > middle && middle > bottom) {
		if (top - middle > middle - bottom) {
			/* Bottom segment is the short one.  */
			int len = middle - bottom;
			int i;

			/* Swap it with the top part of the top segment.  */
			for (i = 0; i < len; i++) {
				tem = argv[bottom + i];
				argv[bottom + i] =
					argv[top - (middle - bottom) + i];
				argv[top - (middle - bottom) + i] = tem;
			}
			/* Exclude the moved bottom segment from further swapping.  */
			top -= len;
		} else {
			/* Top segment is the short one.  */
			int len = top - middle;
			int i;

			/* Swap it with the bottom part of the bottom segment.  */
			for (i = 0; i < len; i++) {
				tem = argv[bottom + i];
				argv[bottom + i] = argv[middle + i];
				argv[middle + i] = tem;
			}
			/* Exclude the moved top segment from further swapping.  */
			bottom += len;
		}
	}
	/* Update records for the slots the non-options now occupy.  */
	d->first_nonopt += (d->custom_optind - d->last_nonopt);
	d->last_nonopt = d->custom_optind;
}

/* Initialize the internal data when the first call is made.  */
static void custom_getopt_initialize(struct custom_getopt_data *d)
{
	/*
	 * Start processing options with ARGV-element 1 (since ARGV-element 0
	 * is the program name); the sequence of previously skipped non-option
	 * ARGV-elements is empty.
	 */
	d->first_nonopt = d->last_nonopt = d->custom_optind;
	d->nextchar = NULL;
	d->initialized = 1;
}

#define NONOPTION_P (argv[d->custom_optind][0] != '-' || argv[d->custom_optind][1] == '\0')

/* return: zero: continue, nonzero: return given value to user */
static int shuffle_argv(int argc, char *const *argv,const struct option *longopts,
	struct custom_getopt_data *d)
{
	/*
	 * Give FIRST_NONOPT & LAST_NONOPT rational values if CUSTOM_OPTIND has been
	 * moved back by the user (who may also have changed the arguments).
	 */
	if (d->last_nonopt > d->custom_optind)
		d->last_nonopt = d->custom_optind;
	if (d->first_nonopt > d->custom_optind)
		d->first_nonopt = d->custom_optind;
	/*
	 * If we have just processed some options following some
	 * non-options, exchange them so that the options come first.
	 */
	if (d->first_nonopt != d->last_nonopt &&
			d->last_nonopt != d->custom_optind)
		exchange((char **) argv, d);
	else if (d->last_nonopt != d->custom_optind)
		d->first_nonopt = d->custom_optind;
	/*
	 * Skip any additional non-options and extend the range of
	 * non-options previously skipped.
	 */
	while (d->custom_optind < argc && NONOPTION_P)
		d->custom_optind++;
	d->last_nonopt = d->custom_optind;
	/*
	 * The special ARGV-element `--' means premature end of options.  Skip
	 * it like a null option, then exchange with previous non-options as if
	 * it were an option, then skip everything else like a non-option.
	 */
	if (d->custom_optind != argc && !strcmp(argv[d->custom_optind], "--")) {
		d->custom_optind++;
		if (d->first_nonopt != d->last_nonopt
				&& d->last_nonopt != d->custom_optind)
			exchange((char **) argv, d);
		else if (d->first_nonopt == d->last_nonopt)
			d->first_nonopt = d->custom_optind;
		d->last_nonopt = argc;
		d->custom_optind = argc;
	}
	/*
	 * If we have done all the ARGV-elements, stop the scan and back over
	 * any non-options that we skipped and permuted.
	 */
	if (d->custom_optind == argc) {
		/*
		 * Set the next-arg-index to point at the non-options that we
		 * previously skipped, so the caller will digest them.
		 */
		if (d->first_nonopt != d->last_nonopt)
			d->custom_optind = d->first_nonopt;
		return -1;
	}
	/*
	 * If we have come to a non-option and did not permute it, either stop
	 * the scan or describe it to the caller and pass it by.
	 */
	if (NONOPTION_P) {
		d->custom_optarg = argv[d->custom_optind++];
		return 1;
	}
	/*
	 * We have found another option-ARGV-element. Skip the initial
	 * punctuation.
	 */
	d->nextchar = (argv[d->custom_optind] + 1 + (longopts != NULL && argv[d->custom_optind][1] == '-'));
	return 0;
}

/*
 * Check whether the ARGV-element is a long option.
 *
 * If there's a long option "fubar" and the ARGV-element is "-fu", consider
 * that an abbreviation of the long option, just like "--fu", and not "-f" with
 * arg "u".
 *
 * This distinction seems to be the most useful approach.
 *
 */
static int check_long_opt(int argc, char *const *argv, const char *optstring,
		const struct option *longopts, int *longind,
		int print_errors, struct custom_getopt_data *d)
{
	char *nameend;
	const struct option *p;
	const struct option *pfound = NULL;
	int exact = 0;
	int ambig = 0;
	int indfound = -1;
	int option_index;

	for (nameend = d->nextchar; *nameend && *nameend != '='; nameend++)
		/* Do nothing.  */ ;

	/* Test all long options for either exact match or abbreviated matches */
	for (p = longopts, option_index = 0; p->name; p++, option_index++)
		if (!strncmp(p->name, d->nextchar, nameend - d->nextchar)) {
			if ((unsigned int) (nameend - d->nextchar)
					== (unsigned int) strlen(p->name)) {
				/* Exact match found.  */
				pfound = p;
				indfound = option_index;
				exact = 1;
				break;
			} else if (pfound == NULL) {
				/* First nonexact match found.  */
				pfound = p;
				indfound = option_index;
			} else if (pfound->has_arg != p->has_arg
					|| pfound->flag != p->flag
					|| pfound->val != p->val)
				/* Second or later nonexact match found.  */
				ambig = 1;
		}
	if (ambig && !exact) {
		if (print_errors) {
			fprintf(stderr,
				"%s: option `%s' is ambiguous\n",
				argv[0], argv[d->custom_optind]);
		}
		d->nextchar += strlen(d->nextchar);
		d->custom_optind++;
		d->custom_optopt = 0;
		return '?';
	}
	if (pfound) {
		option_index = indfound;
		d->custom_optind++;
		if (*nameend) {
			if (pfound->has_arg != no_argument)
				d->custom_optarg = nameend + 1;
			else {
				if (print_errors) {
					if (argv[d->custom_optind - 1][1] == '-') {
						/* --option */
						fprintf(stderr, "%s: option `--%s' doesn't allow an argument\n",
							argv[0], pfound->name);
					} else {
						/* +option or -option */
						fprintf(stderr, "%s: option `%c%s' doesn't allow an argument\n",
							argv[0], argv[d->custom_optind - 1][0], pfound->name);
					}

				}
				d->nextchar += strlen(d->nextchar);
				d->custom_optopt = pfound->val;
				return '?';
			}
		} else if (pfound->has_arg == required_argument) {
			if (d->custom_optind < argc)
				d->custom_optarg = argv[d->custom_optind++];
			else {
				if (print_errors) {
					fprintf(stderr,
						"%s: option `%s' requires an argument\n",
						argv[0],
						argv[d->custom_optind - 1]);
				}
				d->nextchar += strlen(d->nextchar);
				d->custom_optopt = pfound->val;
				return optstring[0] == ':' ? ':' : '?';
			}
		}
		d->nextchar += strlen(d->nextchar);
		if (longind != NULL)
			*longind = option_index;
		if (pfound->flag) {
			*(pfound->flag) = pfound->val;
			return 0;
		}
		return pfound->val;
	}
	/*
	 * Can't find it as a long option.  If this is not getopt_long_only, or
	 * the option starts with '--' or is not a valid short option, then
	 * it's an error.  Otherwise interpret it as a short option.
	 */
	if (print_errors) {
		if (argv[d->custom_optind][1] == '-') {
			/* --option */
			fprintf(stderr,
				"%s: unrecognized option `--%s'\n",
				argv[0], d->nextchar);
		} else {
			/* +option or -option */
			fprintf(stderr,
				"%s: unrecognized option `%c%s'\n",
				argv[0], argv[d->custom_optind][0],
				d->nextchar);
		}
	}
	d->nextchar = (char *) "";
	d->custom_optind++;
	d->custom_optopt = 0;
	return '?';
}

static int check_short_opt(int argc, char *const *argv, const char *optstring,
		int print_errors, struct custom_getopt_data *d)
{
	char c = *d->nextchar++;
	const char *temp = strchr(optstring, c);

	/* Increment `custom_optind' when we start to process its last character.  */
	if (*d->nextchar == '\0')
		++d->custom_optind;
	if (!temp || c == ':') {
		if (print_errors)
			fprintf(stderr, "%s: invalid option -- %c\n", argv[0], c);

		d->custom_optopt = c;
		return '?';
	}
	if (temp[1] == ':') {
		if (temp[2] == ':') {
			/* This is an option that accepts an argument optionally.  */
			if (*d->nextchar != '\0') {
				d->custom_optarg = d->nextchar;
				d->custom_optind++;
			} else
				d->custom_optarg = NULL;
			d->nextchar = NULL;
		} else {
			/* This is an option that requires an argument.  */
			if (*d->nextchar != '\0') {
				d->custom_optarg = d->nextchar;
				/*
				 * If we end this ARGV-element by taking the
				 * rest as an arg, we must advance to the next
				 * element now.
				 */
				d->custom_optind++;
			} else if (d->custom_optind == argc) {
				if (print_errors) {
					fprintf(stderr,
						"%s: option requires an argument -- %c\n",
						argv[0], c);
				}
				d->custom_optopt = c;
				if (optstring[0] == ':')
					c = ':';
				else
					c = '?';
			} else
				/*
				 * We already incremented `custom_optind' once;
				 * increment it again when taking next ARGV-elt
				 * as argument.
				 */
				d->custom_optarg = argv[d->custom_optind++];
			d->nextchar = NULL;
		}
	}
	return c;
}

/*
 * Scan elements of ARGV for option characters given in OPTSTRING.
 *
 * If an element of ARGV starts with '-', and is not exactly "-" or "--",
 * then it is an option element.  The characters of this element
 * (aside from the initial '-') are option characters.  If `getopt'
 * is called repeatedly, it returns successively each of the option characters
 * from each of the option elements.
 *
 * If `getopt' finds another option character, it returns that character,
 * updating `custom_optind' and `nextchar' so that the next call to `getopt' can
 * resume the scan with the following option character or ARGV-element.
 *
 * If there are no more option characters, `getopt' returns -1.
 * Then `custom_optind' is the index in ARGV of the first ARGV-element
 * that is not an option.  (The ARGV-elements have been permuted
 * so that those that are not options now come last.)
 *
 * OPTSTRING is a string containing the legitimate option characters.
 * If an option character is seen that is not listed in OPTSTRING,
 * return '?' after printing an error message.  If you set `custom_opterr' to
 * zero, the error message is suppressed but we still return '?'.
 *
 * If a char in OPTSTRING is followed by a colon, that means it wants an arg,
 * so the following text in the same ARGV-element, or the text of the following
 * ARGV-element, is returned in `custom_optarg'.  Two colons mean an option that
 * wants an optional arg; if there is text in the current ARGV-element,
 * it is returned in `custom_optarg', otherwise `custom_optarg' is set to zero.
 *
 * If OPTSTRING starts with `-' or `+', it requests different methods of
 * handling the non-option ARGV-elements.
 * See the comments about RETURN_IN_ORDER and REQUIRE_ORDER, above.
 *
 * Long-named options begin with `--' instead of `-'.
 * Their names may be abbreviated as long as the abbreviation is unique
 * or is an exact match for some defined option.  If they have an
 * argument, it follows the option name in the same ARGV-element, separated
 * from the option name by a `=', or else the in next ARGV-element.
 * When `getopt' finds a long-named option, it returns 0 if that option's
 * `flag' field is nonzero, the value of the option's `val' field
 * if the `flag' field is zero.
 *
 * The elements of ARGV aren't really const, because we permute them.
 * But we pretend they're const in the prototype to be compatible
 * with other systems.
 *
 * LONGOPTS is a vector of `struct option' terminated by an
 * element containing a name which is zero.
 *
 * LONGIND returns the index in LONGOPT of the long-named option found.
 * It is only valid when a long-named option has been found by the most
 * recent call.
 *
 * Return the option character from OPTS just read.  Return -1 when there are
 * no more options.  For unrecognized options, or options missing arguments,
 * `custom_optopt' is set to the option letter, and '?' is returned.
 *
 * The OPTS string is a list of characters which are recognized option letters,
 * optionally followed by colons, specifying that that letter takes an
 * argument, to be placed in `custom_optarg'.
 *
 * If a letter in OPTS is followed by two colons, its argument is optional.
 * This behavior is specific to the GNU `getopt'.
 *
 * The argument `--' causes premature termination of argument scanning,
 * explicitly telling `getopt' that there are no more options.  If OPTS begins
 * with `--', then non-option arguments are treated as arguments to the option
 * '\0'.  This behavior is specific to the GNU `getopt'.
 */

static int getopt_internal_r(int argc, char *const *argv, const char *optstring,
		const struct option *longopts, int *longind,
		struct custom_getopt_data *d)
{
	int ret, print_errors = d->custom_opterr;

	if (optstring[0] == ':')
		print_errors = 0;
	if (argc < 1)
		return -1;
	d->custom_optarg = NULL;

	/* 
	 * This is a big difference with GNU getopt, since optind == 0
	 * means initialization while here 1 means first call.
	 */
	if (d->custom_optind == 0 || !d->initialized) {
		if (d->custom_optind == 0)
			d->custom_optind = 1;	/* Don't scan ARGV[0], the program name.  */
		custom_getopt_initialize(d);
	}
	if (d->nextchar == NULL || *d->nextchar == '\0') {
		ret = shuffle_argv(argc, argv, longopts, d);
		if (ret)
			return ret;
	}
	if (longopts && (argv[d->custom_optind][1] == '-' ))
		return check_long_opt(argc, argv, optstring, longopts,
			longind, print_errors, d);
	return check_short_opt(argc, argv, optstring, print_errors, d);
}

static int custom_getopt_internal(int argc, char *const *argv, const char *optstring,
	const struct option *longopts, int *longind)
{
	int result;
	/* Keep a global copy of all internal members of d */
	static struct custom_getopt_data d;

	d.custom_optind = custom_optind;
	d.custom_opterr = custom_opterr;
	result = getopt_internal_r(argc, argv, optstring, longopts,
		longind, &d);
	custom_optind = d.custom_optind;
	custom_optarg = d.custom_optarg;
	custom_optopt = d.custom_optopt;
	return result;
}

static int custom_getopt_long (int argc, char *const *argv, const char *options,
	const struct option *long_options, int *opt_index)
{
	return custom_getopt_internal(argc, argv, options, long_options,
		opt_index);
}


static char *package_name = 0;

/**
 * @brief updates an option
 * @param field the generic pointer to the field to update
 * @param orig_field the pointer to the orig field
 * @param field_given the pointer to the number of occurrence of this option
 * @param prev_given the pointer to the number of occurrence already seen
 * @param value the argument for this option (if null no arg was specified)
 * @param possible_values the possible values for this option (if specified)
 * @param default_value the default value (in case the option only accepts fixed values)
 * @param arg_type the type of this option
 * @param check_ambiguity @see my_cmdline_parser_params.check_ambiguity
 * @param override @see my_cmdline_parser_params.override
 * @param no_free whether to free a possible previous value
 * @param multiple_option whether this is a multiple option
 * @param long_opt the corresponding long option
 * @param short_opt the corresponding short option (or '-' if none)
 * @param additional_error possible further error specification
 */
static
int update_arg(void *field, char **orig_field,
               unsigned int *field_given, unsigned int *prev_given, 
               char *value, const char *possible_values[],
               const char *default_value,
               my_cmdline_parser_arg_type arg_type,
               int check_ambiguity, int override,
               int no_free, int multiple_option,
               const char *long_opt, char short_opt,
               const char *additional_error)
{
  char *stop_char = 0;
  const char *val = value;
  int found;
  char **string_field;
  FIX_UNUSED (field);

  stop_char = 0;
  found = 0;

  if (!multiple_option && prev_given && (*prev_given || (check_ambiguity && *field_given)))
    {
      if (short_opt != '-')
        fprintf (stderr, "%s: `--%s' (`-%c') option given more than once%s\n", 
               package_name, long_opt, short_opt,
               (additional_error ? additional_error : ""));
      else
        fprintf (stderr, "%s: `--%s' option given more than once%s\n", 
               package_name, long_opt,
               (additional_error ? additional_error : ""));
      return 1; /* failure */
    }

  if (possible_values && (found = check_possible_values((value ? value : default_value), possible_values)) < 0)
    {
      if (short_opt != '-')
        fprintf (stderr, "%s: %s argument, \"%s\", for option `--%s' (`-%c')%s\n", 
          package_name, (found == -2) ? "ambiguous" : "invalid", value, long_opt, short_opt,
          (additional_error ? additional_error : ""));
      else
        fprintf (stderr, "%s: %s argument, \"%s\", for option `--%s'%s\n", 
          package_name, (found == -2) ? "ambiguous" : "invalid", value, long_opt,
          (additional_error ? additional_error : ""));
      return 1; /* failure */
    }
    
  if (field_given && *field_given && ! override)
    return 0;
  if (prev_given)
    (*prev_given)++;
  if (field_given)
    (*field_given)++;
  if (possible_values)
    val = possible_values[found];

  switch(arg_type) {
  case ARG_FLAG:
    *((int *)field) = !*((int *)field);
    break;
  case ARG_LONG:
    if (val) *((long *)field) = (long)strtol (val, &stop_char, 0);
    break;
  case ARG_DOUBLE:
    if (val) *((double *)field) = strtod (val, &stop_char);
    break;
  case ARG_ENUM:
    if (val) *((int *)field) = found;
    break;
  case ARG_STRING:
    if (val) {
      string_field = (char **)field;
      if (!no_free && *string_field)
        free (*string_field); /* free previous string */
      *string_field = gengetopt_strdup (val);
    }
    break;
  default:
    break;
  };

  /* check numeric conversion */
  switch(arg_type) {
  case ARG_LONG:
  case ARG_DOUBLE:
    if (val && !(stop_char && *stop_char == '\0')) {
      fprintf(stderr, "%s: invalid numeric value: %s\n", package_name, val);
      return 1; /* failure */
    }
    break;
  default:
    ;
  };

  /* store the original value */
  switch(arg_type) {
  case ARG_NO:
  case ARG_FLAG:
    break;
  default:
    if (value && orig_field) {
      if (no_free) {
        *orig_field = value;
      } else {
        if (*orig_field)
          free (*orig_field); /* free previous string */
        *orig_field = gengetopt_strdup (value);
      }
    }
  };

  return 0; /* OK */
}


int
my_cmdline_parser_internal (
  int argc, char **argv, struct gengetopt_args_info *args_info,
                        struct my_cmdline_parser_params *params, const char *additional_error)
{
  int c;	/* Character of the parsed option.  */

  int error_occurred = 0;
  struct gengetopt_args_info local_args_info;
  
  int override;
  int initialize;
  int check_required;
  int check_ambiguity;

  char *optarg;
  int optind;
  int opterr;
  int optopt;
  
  package_name = argv[0];
  
  override = params->override;
  initialize = params->initialize;
  check_required = params->check_required;
  check_ambiguity = params->check_ambiguity;

  if (initialize)
    my_cmdline_parser_init (args_info);

  my_cmdline_parser_init (&local_args_info);

  optarg = 0;
  optind = 0;
  opterr = params->print_errors;
  optopt = '?';

  while (1)
    {
      int option_index = 0;

      static struct option long_options[] = {
        { "version",	0, NULL, 'V' },
        { "help",	0, NULL, 'h' },
        { "detailed-help",	0, NULL, 0 },
        { "full-help",	0, NULL, 0 },
        { "count",	0, NULL, 0 },
        { "kmer",	1, NULL, 'k' },
        { "disk",	1, NULL, 0 },
        { "load-disk",	1, NULL, 0 },
        { "memory",	1, NULL, 0 },
        { "load-memory",	1, NULL, 0 },
        { "nthread",	1, NULL, 't' },
        { "outfile",	1, NULL, 'o' },
        { "outdir",	1, NULL, 0 },
        { "nh",	1, NULL, 0 },
        { "no-partition",	0, NULL, 0 },
        { "no-count",	0, NULL, 0 },
        { "no-delete",	0, NULL, 0 },
        { "report",	0, NULL, 0 },
        { "summary",	0, NULL, 0 },
        { "fasta",	0, NULL, 0 },
        { "no-tab",	0, NULL, 0 },
        { "query",	0, NULL, 0 },
        { "sequence",	1, NULL, 0 },
        { "simulate",	0, NULL, 0 },
        { "maxkmer",	1, NULL, 0 },
        { "format",	1, NULL, 0 },
        { "ni",	1, NULL, 0 },
        { "np",	1, NULL, 0 },
        { "nf",	1, NULL, 0 },
        { "seqlen",	1, NULL, 0 },
        { "seed",	1, NULL, 0 },
        { "partition",	0, NULL, 0 },
        { "inbuffer",	1, NULL, 0 },
        { "outbuffer",	1, NULL, 0 },
        { "decode",	0, NULL, 0 },
        { "table",	0, NULL, 0 },
        { "list",	0, NULL, 0 },
        { "match",	0, NULL, 0 },
        { "tabfile",	1, NULL, 0 },
        { "binary",	0, NULL, 0 },
        { "uncompress",	0, NULL, 0 },
        { "inspect",	0, NULL, 0 },
        { "cite",	0, NULL, 0 },
        { "log",	2, NULL, 0 },
        { "progress",	0, NULL, 0 },
        { "loglevel",	1, NULL, 0 },
        { "progress-to-stderr",	0, NULL, 0 },
        { "totalmaxkmer",	1, NULL, 0 },
        { "select-version",	1, NULL, 0 },
        { "bin-outdir",	1, NULL, 0 },
        { "par-outdir",	1, NULL, 0 },
        { "tab-outdir",	1, NULL, 0 },
        { "mer-len",	1, NULL, 'm' },
        { "canonical",	0, NULL, 'C' },
        { "lower-count",	1, NULL, 'L' },
        { "upper-count",	1, NULL, 'U' },
        { "size",	1, NULL, 0 },
        { "threads",	1, NULL, 0 },
        { "output",	1, NULL, 0 },
        { "with-reverse",	0, NULL, 0 },
        { "with-index",	0, NULL, 0 },
        { "only-init",	0, NULL, 0 },
        { "with-parfile",	0, NULL, 0 },
        { "min-table-memory",	1, NULL, 0 },
        { "max-table-memory",	1, NULL, 0 },
        { "release",	0, NULL, 0 },
        { "exit",	0, NULL, 0 },
        { "examples",	0, NULL, 0 },
        { "document",	0, NULL, 0 },
        { 0,  0, 0, 0 }
      };

      custom_optarg = optarg;
      custom_optind = optind;
      custom_opterr = opterr;
      custom_optopt = optopt;

      c = custom_getopt_long (argc, argv, "Vhk:t:o:m:CL:U:", long_options, &option_index);

      optarg = custom_optarg;
      optind = custom_optind;
      opterr = custom_opterr;
      optopt = custom_optopt;

      if (c == -1) break;	/* Exit from `while (1)' loop.  */

      switch (c)
        {
        case 'V':	/* Print version and exit.  */
          my_cmdline_parser_print_version ();
          my_cmdline_parser_free (&local_args_info);
          exit (EXIT_SUCCESS);

        case 'h':	/* Print help of the program, or a command: e.g., alder-kmer count -h.  */
        
        
          if (update_arg((void *)&(args_info->help_flag), 0, &(args_info->help_given),
              &(local_args_info.help_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "help", 'h',
              additional_error))
            goto failure;
        
          break;
        case 'k':	/* k-mer size.  */
        
        
          if (update_arg( (void *)&(args_info->kmer_arg), 
               &(args_info->kmer_orig), &(args_info->kmer_given),
              &(local_args_info.kmer_given), optarg, 0, "1", ARG_LONG,
              check_ambiguity, override, 0, 0,
              "kmer", 'k',
              additional_error))
            goto failure;
        
          break;
        case 't':	/* number of threads.  */
        
        
          if (update_arg( (void *)&(args_info->nthread_arg), 
               &(args_info->nthread_orig), &(args_info->nthread_given),
              &(local_args_info.nthread_given), optarg, 0, "1", ARG_LONG,
              check_ambiguity, override, 0, 0,
              "nthread", 't',
              additional_error))
            goto failure;
        
          break;
        case 'o':	/* prefix of output files.  */
        
        
          if (update_arg( (void *)&(args_info->outfile_arg), 
               &(args_info->outfile_orig), &(args_info->outfile_given),
              &(local_args_info.outfile_given), optarg, 0, "outfile", ARG_STRING,
              check_ambiguity, override, 0, 0,
              "outfile", 'o',
              additional_error))
            goto failure;
        
          break;
        case 'm':	/* k-mer size.  */
        
        
          if (update_arg( (void *)&(args_info->mer_len_arg), 
               &(args_info->mer_len_orig), &(args_info->mer_len_given),
              &(local_args_info.mer_len_given), optarg, 0, "1", ARG_LONG,
              check_ambiguity, override, 0, 0,
              "mer-len", 'm',
              additional_error))
            goto failure;
        
          break;
        case 'C':	/* Count both strand.  */
        
        
          if (update_arg((void *)&(args_info->canonical_flag), 0, &(args_info->canonical_given),
              &(local_args_info.canonical_given), optarg, 0, 0, ARG_FLAG,
              check_ambiguity, override, 1, 0, "canonical", 'C',
              additional_error))
            goto failure;
        
          break;
        case 'L':	/* minimum count.  */
        
        
          if (update_arg( (void *)&(args_info->lower_count_arg), 
               &(args_info->lower_count_orig), &(args_info->lower_count_given),
              &(local_args_info.lower_count_given), optarg, 0, "1", ARG_LONG,
              check_ambiguity, override, 0, 0,
              "lower-count", 'L',
              additional_error))
            goto failure;
        
          break;
        case 'U':	/* maximum count.  */
        
        
          if (update_arg( (void *)&(args_info->upper_count_arg), 
               &(args_info->upper_count_orig), &(args_info->upper_count_given),
              &(local_args_info.upper_count_given), optarg, 0, "65535", ARG_LONG,
              check_ambiguity, override, 0, 0,
              "upper-count", 'U',
              additional_error))
            goto failure;
        
          break;

        case 0:	/* Long option with no short option */
          /* Print help, including all details.  */
          if (strcmp (long_options[option_index].name, "detailed-help") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->detailed_help_flag), 0, &(args_info->detailed_help_given),
                &(local_args_info.detailed_help_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "detailed-help", '-',
                additional_error))
              goto failure;
          
          }
          /* Print help with documents.  */
          else if (strcmp (long_options[option_index].name, "full-help") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->full_help_flag), 0, &(args_info->full_help_given),
                &(local_args_info.full_help_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "full-help", '-',
                additional_error))
              goto failure;
          
          }
          /* Count k-mer data.  */
          else if (strcmp (long_options[option_index].name, "count") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->count_flag), 0, &(args_info->count_given),
                &(local_args_info.count_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "count", '-',
                additional_error))
              goto failure;
          
          }
          /* maximum disk space.  */
          else if (strcmp (long_options[option_index].name, "disk") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->disk_arg), 
                 &(args_info->disk_orig), &(args_info->disk_given),
                &(local_args_info.disk_given), optarg, 0, "10", ARG_LONG,
                check_ambiguity, override, 0, 0,
                "disk", '-',
                additional_error))
              goto failure;
          
          }
          /* fraction of disk.  */
          else if (strcmp (long_options[option_index].name, "load-disk") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->load_disk_arg), 
                 &(args_info->load_disk_orig), &(args_info->load_disk_given),
                &(local_args_info.load_disk_given), optarg, 0, "1.0", ARG_DOUBLE,
                check_ambiguity, override, 0, 0,
                "load-disk", '-',
                additional_error))
              goto failure;
          
          }
          /* maximum memory.  */
          else if (strcmp (long_options[option_index].name, "memory") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->memory_arg), 
                 &(args_info->memory_orig), &(args_info->memory_given),
                &(local_args_info.memory_given), optarg, 0, "10", ARG_LONG,
                check_ambiguity, override, 0, 0,
                "memory", '-',
                additional_error))
              goto failure;
          
          }
          /* fraction of memory.  */
          else if (strcmp (long_options[option_index].name, "load-memory") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->load_memory_arg), 
                 &(args_info->load_memory_orig), &(args_info->load_memory_given),
                &(local_args_info.load_memory_given), optarg, 0, "1.0", ARG_DOUBLE,
                check_ambiguity, override, 0, 0,
                "load-memory", '-',
                additional_error))
              goto failure;
          
          }
          /* output directory.  */
          else if (strcmp (long_options[option_index].name, "outdir") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->outdir_arg), 
                 &(args_info->outdir_orig), &(args_info->outdir_given),
                &(local_args_info.outdir_given), optarg, 0, ".", ARG_STRING,
                check_ambiguity, override, 0, 0,
                "outdir", '-',
                additional_error))
              goto failure;
          
          }
          /* number of hash elements.  */
          else if (strcmp (long_options[option_index].name, "nh") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->nh_arg), 
                 &(args_info->nh_orig), &(args_info->nh_given),
                &(local_args_info.nh_given), optarg, 0, "10", ARG_LONG,
                check_ambiguity, override, 0, 0,
                "nh", '-',
                additional_error))
              goto failure;
          
          }
          /* Skip partitioning sequence files..  */
          else if (strcmp (long_options[option_index].name, "no-partition") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->no_partition_flag), 0, &(args_info->no_partition_given),
                &(local_args_info.no_partition_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "no-partition", '-',
                additional_error))
              goto failure;
          
          }
          /* Skip counting..  */
          else if (strcmp (long_options[option_index].name, "no-count") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->no_count_flag), 0, &(args_info->no_count_given),
                &(local_args_info.no_count_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "no-count", '-',
                additional_error))
              goto failure;
          
          }
          /* Do not delete partition files; on with --no-count.  */
          else if (strcmp (long_options[option_index].name, "no-delete") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->no_delete_flag), 0, &(args_info->no_delete_given),
                &(local_args_info.no_delete_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "no-delete", '-',
                additional_error))
              goto failure;
          
          }
          /* Report the count table.  */
          else if (strcmp (long_options[option_index].name, "report") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->report_flag), 0, &(args_info->report_given),
                &(local_args_info.report_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "report", '-',
                additional_error))
              goto failure;
          
          }
          /* Display summary of the table.  */
          else if (strcmp (long_options[option_index].name, "summary") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->summary_flag), 0, &(args_info->summary_given),
                &(local_args_info.summary_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "summary", '-',
                additional_error))
              goto failure;
          
          }
          /* fasta format: >count newline kmer.  */
          else if (strcmp (long_options[option_index].name, "fasta") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->fasta_flag), 0, &(args_info->fasta_given),
                &(local_args_info.fasta_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "fasta", '-',
                additional_error))
              goto failure;
          
          }
          /* Space separator.  */
          else if (strcmp (long_options[option_index].name, "no-tab") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->no_tab_flag), 0, &(args_info->no_tab_given),
                &(local_args_info.no_tab_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "no-tab", '-',
                additional_error))
              goto failure;
          
          }
          /* dummy.  */
          else if (strcmp (long_options[option_index].name, "query") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->query_flag), 0, &(args_info->query_given),
                &(local_args_info.query_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "query", '-',
                additional_error))
              goto failure;
          
          }
          /* Query a kmer DNA sequence.  */
          else if (strcmp (long_options[option_index].name, "sequence") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->sequence_arg), 
                 &(args_info->sequence_orig), &(args_info->sequence_given),
                &(local_args_info.sequence_given), optarg, 0, 0, ARG_STRING,
                check_ambiguity, override, 0, 0,
                "sequence", '-',
                additional_error))
              goto failure;
          
          }
          /* Simulate k-mer data.  */
          else if (strcmp (long_options[option_index].name, "simulate") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->simulate_flag), 0, &(args_info->simulate_given),
                &(local_args_info.simulate_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "simulate", '-',
                additional_error))
              goto failure;
          
          }
          /* number of kmers in a file.  */
          else if (strcmp (long_options[option_index].name, "maxkmer") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->maxkmer_arg), 
                 &(args_info->maxkmer_orig), &(args_info->maxkmer_given),
                &(local_args_info.maxkmer_given), optarg, 0, "1000", ARG_LONG,
                check_ambiguity, override, 0, 0,
                "maxkmer", '-',
                additional_error))
              goto failure;
          
          }
          /* generated sequence file format.  */
          else if (strcmp (long_options[option_index].name, "format") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->format_arg), 
                 &(args_info->format_orig), &(args_info->format_given),
                &(local_args_info.format_given), optarg, my_cmdline_parser_format_values, "fastq", ARG_ENUM,
                check_ambiguity, override, 0, 0,
                "format", '-',
                additional_error))
              goto failure;
          
          }
          /* number of iterations.  */
          else if (strcmp (long_options[option_index].name, "ni") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->ni_arg), 
                 &(args_info->ni_orig), &(args_info->ni_given),
                &(local_args_info.ni_given), optarg, 0, "1", ARG_LONG,
                check_ambiguity, override, 0, 0,
                "ni", '-',
                additional_error))
              goto failure;
          
          }
          /* number of partitions.  */
          else if (strcmp (long_options[option_index].name, "np") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->np_arg), 
                 &(args_info->np_orig), &(args_info->np_given),
                &(local_args_info.np_given), optarg, 0, "1", ARG_LONG,
                check_ambiguity, override, 0, 0,
                "np", '-',
                additional_error))
              goto failure;
          
          }
          /* number of sequences files.  */
          else if (strcmp (long_options[option_index].name, "nf") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->nf_arg), 
                 &(args_info->nf_orig), &(args_info->nf_given),
                &(local_args_info.nf_given), optarg, 0, "1", ARG_LONG,
                check_ambiguity, override, 0, 0,
                "nf", '-',
                additional_error))
              goto failure;
          
          }
          /* maximum sequence length.  */
          else if (strcmp (long_options[option_index].name, "seqlen") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->seqlen_arg), 
                 &(args_info->seqlen_orig), &(args_info->seqlen_given),
                &(local_args_info.seqlen_given), optarg, 0, "100", ARG_LONG,
                check_ambiguity, override, 0, 0,
                "seqlen", '-',
                additional_error))
              goto failure;
          
          }
          /* random seed.  */
          else if (strcmp (long_options[option_index].name, "seed") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->seed_arg), 
                 &(args_info->seed_orig), &(args_info->seed_given),
                &(local_args_info.seed_given), optarg, 0, "-1", ARG_LONG,
                check_ambiguity, override, 0, 0,
                "seed", '-',
                additional_error))
              goto failure;
          
          }
          /* Create a partition file.  */
          else if (strcmp (long_options[option_index].name, "partition") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->partition_flag), 0, &(args_info->partition_given),
                &(local_args_info.partition_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "partition", '-',
                additional_error))
              goto failure;
          
          }
          /* Size of input buffer in log2.  */
          else if (strcmp (long_options[option_index].name, "inbuffer") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->inbuffer_arg), 
                 &(args_info->inbuffer_orig), &(args_info->inbuffer_given),
                &(local_args_info.inbuffer_given), optarg, 0, "0", ARG_LONG,
                check_ambiguity, override, 0, 0,
                "inbuffer", '-',
                additional_error))
              goto failure;
          
          }
          /* Size of output buffer in log2.  */
          else if (strcmp (long_options[option_index].name, "outbuffer") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->outbuffer_arg), 
                 &(args_info->outbuffer_orig), &(args_info->outbuffer_given),
                &(local_args_info.outbuffer_given), optarg, 0, "0", ARG_LONG,
                check_ambiguity, override, 0, 0,
                "outbuffer", '-',
                additional_error))
              goto failure;
          
          }
          /* Decode a partition file.  */
          else if (strcmp (long_options[option_index].name, "decode") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->decode_flag), 0, &(args_info->decode_given),
                &(local_args_info.decode_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "decode", '-',
                additional_error))
              goto failure;
          
          }
          /* Partition file.  */
          else if (strcmp (long_options[option_index].name, "table") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->table_flag), 0, &(args_info->table_given),
                &(local_args_info.table_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "table", '-',
                additional_error))
              goto failure;
          
          }
          /* List kmers in a text file. Options: kmer, seqlen.  */
          else if (strcmp (long_options[option_index].name, "list") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->list_flag), 0, &(args_info->list_given),
                &(local_args_info.list_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "list", '-',
                additional_error))
              goto failure;
          
          }
          /* Compare a table file and input sequence data..  */
          else if (strcmp (long_options[option_index].name, "match") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->match_flag), 0, &(args_info->match_given),
                &(local_args_info.match_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "match", '-',
                additional_error))
              goto failure;
          
          }
          /* a table file.  */
          else if (strcmp (long_options[option_index].name, "tabfile") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->tabfile_arg), 
                 &(args_info->tabfile_orig), &(args_info->tabfile_given),
                &(local_args_info.tabfile_given), optarg, 0, "outfile.tbl", ARG_STRING,
                check_ambiguity, override, 0, 0,
                "tabfile", '-',
                additional_error))
              goto failure;
          
          }
          /* Create a binary file from sequence file..  */
          else if (strcmp (long_options[option_index].name, "binary") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->binary_flag), 0, &(args_info->binary_given),
                &(local_args_info.binary_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "binary", '-',
                additional_error))
              goto failure;
          
          }
          /* Create a simple form of a sequence file from an alder-kmer binary file..  */
          else if (strcmp (long_options[option_index].name, "uncompress") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->uncompress_flag), 0, &(args_info->uncompress_given),
                &(local_args_info.uncompress_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "uncompress", '-',
                additional_error))
              goto failure;
          
          }
          /* inspect command.  */
          else if (strcmp (long_options[option_index].name, "inspect") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->inspect_flag), 0, &(args_info->inspect_given),
                &(local_args_info.inspect_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "inspect", '-',
                additional_error))
              goto failure;
          
          }
          /* Print reference papers.  */
          else if (strcmp (long_options[option_index].name, "cite") == 0)
          {
          
          
            if (update_arg( 0 , 
                 0 , &(args_info->cite_given),
                &(local_args_info.cite_given), optarg, 0, 0, ARG_NO,
                check_ambiguity, override, 0, 0,
                "cite", '-',
                additional_error))
              goto failure;
          
          }
          /* Log file using option outfile.  */
          else if (strcmp (long_options[option_index].name, "log") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->log_arg), 
                 &(args_info->log_orig), &(args_info->log_given),
                &(local_args_info.log_given), optarg, 0, "outfile.log", ARG_STRING,
                check_ambiguity, override, 0, 0,
                "log", '-',
                additional_error))
              goto failure;
          
          }
          /* Display progress.  */
          else if (strcmp (long_options[option_index].name, "progress") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->progress_flag), 0, &(args_info->progress_given),
                &(local_args_info.progress_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "progress", '-',
                additional_error))
              goto failure;
          
          }
          /* Log level.  */
          else if (strcmp (long_options[option_index].name, "loglevel") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->loglevel_arg), 
                 &(args_info->loglevel_orig), &(args_info->loglevel_given),
                &(local_args_info.loglevel_given), optarg, my_cmdline_parser_loglevel_values, "1", ARG_LONG,
                check_ambiguity, override, 0, 0,
                "loglevel", '-',
                additional_error))
              goto failure;
          
          }
          /* Display progress number to stdandard error.  */
          else if (strcmp (long_options[option_index].name, "progress-to-stderr") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->progress_to_stderr_flag), 0, &(args_info->progress_to_stderr_given),
                &(local_args_info.progress_to_stderr_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "progress-to-stderr", '-',
                additional_error))
              goto failure;
          
          }
          /* Skip counting maximum number of kmers in data, and use this number.  */
          else if (strcmp (long_options[option_index].name, "totalmaxkmer") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->totalmaxkmer_arg), 
                 &(args_info->totalmaxkmer_orig), &(args_info->totalmaxkmer_given),
                &(local_args_info.totalmaxkmer_given), optarg, 0, "0", ARG_LONG,
                check_ambiguity, override, 0, 0,
                "totalmaxkmer", '-',
                additional_error))
              goto failure;
          
          }
          /* Select a version of kmer counting: 0 for automatic selction, 1 for skipping binary file creation (dsk mode with a single iteration), 2 for binary file creation (dsk mode), and 3 for loading a whole input data on the memory (msk or memory streaming kmer mode)..  */
          else if (strcmp (long_options[option_index].name, "select-version") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->select_version_arg), 
                 &(args_info->select_version_orig), &(args_info->select_version_given),
                &(local_args_info.select_version_given), optarg, my_cmdline_parser_select_version_values, "0", ARG_LONG,
                check_ambiguity, override, 0, 0,
                "select-version", '-',
                additional_error))
              goto failure;
          
          }
          /* binary file output directory.  */
          else if (strcmp (long_options[option_index].name, "bin-outdir") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->bin_outdir_arg), 
                 &(args_info->bin_outdir_orig), &(args_info->bin_outdir_given),
                &(local_args_info.bin_outdir_given), optarg, 0, ".", ARG_STRING,
                check_ambiguity, override, 0, 0,
                "bin-outdir", '-',
                additional_error))
              goto failure;
          
          }
          /* partition files output directory.  */
          else if (strcmp (long_options[option_index].name, "par-outdir") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->par_outdir_arg), 
                 &(args_info->par_outdir_orig), &(args_info->par_outdir_given),
                &(local_args_info.par_outdir_given), optarg, 0, ".", ARG_STRING,
                check_ambiguity, override, 0, 0,
                "par-outdir", '-',
                additional_error))
              goto failure;
          
          }
          /* table file output directory.  */
          else if (strcmp (long_options[option_index].name, "tab-outdir") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->tab_outdir_arg), 
                 &(args_info->tab_outdir_orig), &(args_info->tab_outdir_given),
                &(local_args_info.tab_outdir_given), optarg, 0, ".", ARG_STRING,
                check_ambiguity, override, 0, 0,
                "tab-outdir", '-',
                additional_error))
              goto failure;
          
          }
          /* hash size.  */
          else if (strcmp (long_options[option_index].name, "size") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->size_arg), 
                 &(args_info->size_orig), &(args_info->size_given),
                &(local_args_info.size_given), optarg, 0, "1", ARG_LONG,
                check_ambiguity, override, 0, 0,
                "size", '-',
                additional_error))
              goto failure;
          
          }
          /* number of threads.  */
          else if (strcmp (long_options[option_index].name, "threads") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->threads_arg), 
                 &(args_info->threads_orig), &(args_info->threads_given),
                &(local_args_info.threads_given), optarg, 0, "1", ARG_LONG,
                check_ambiguity, override, 0, 0,
                "threads", '-',
                additional_error))
              goto failure;
          
          }
          /* prefix of output files.  */
          else if (strcmp (long_options[option_index].name, "output") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->output_arg), 
                 &(args_info->output_orig), &(args_info->output_given),
                &(local_args_info.output_given), optarg, 0, "outfile", ARG_STRING,
                check_ambiguity, override, 0, 0,
                "output", '-',
                additional_error))
              goto failure;
          
          }
          /* Print reverse complementary sequences.  */
          else if (strcmp (long_options[option_index].name, "with-reverse") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->with_reverse_flag), 0, &(args_info->with_reverse_given),
                &(local_args_info.with_reverse_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "with-reverse", '-',
                additional_error))
              goto failure;
          
          }
          /* Print index values.  */
          else if (strcmp (long_options[option_index].name, "with-index") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->with_index_flag), 0, &(args_info->with_index_given),
                &(local_args_info.with_index_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "with-index", '-',
                additional_error))
              goto failure;
          
          }
          /* Do not execute counting, but the initialization.  */
          else if (strcmp (long_options[option_index].name, "only-init") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->only_init_flag), 0, &(args_info->only_init_given),
                &(local_args_info.only_init_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "only-init", '-',
                additional_error))
              goto failure;
          
          }
          /* Create par files as well as sequence files..  */
          else if (strcmp (long_options[option_index].name, "with-parfile") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->with_parfile_flag), 0, &(args_info->with_parfile_given),
                &(local_args_info.with_parfile_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "with-parfile", '-',
                additional_error))
              goto failure;
          
          }
          /* min memory of a part table.  */
          else if (strcmp (long_options[option_index].name, "min-table-memory") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->min_table_memory_arg), 
                 &(args_info->min_table_memory_orig), &(args_info->min_table_memory_given),
                &(local_args_info.min_table_memory_given), optarg, 0, "100", ARG_LONG,
                check_ambiguity, override, 0, 0,
                "min-table-memory", '-',
                additional_error))
              goto failure;
          
          }
          /* max memory of a part table.  */
          else if (strcmp (long_options[option_index].name, "max-table-memory") == 0)
          {
          
          
            if (update_arg( (void *)&(args_info->max_table_memory_arg), 
                 &(args_info->max_table_memory_orig), &(args_info->max_table_memory_given),
                &(local_args_info.max_table_memory_given), optarg, 0, "1000", ARG_LONG,
                check_ambiguity, override, 0, 0,
                "max-table-memory", '-',
                additional_error))
              goto failure;
          
          }
          /* Release mode.  */
          else if (strcmp (long_options[option_index].name, "release") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->release_flag), 0, &(args_info->release_given),
                &(local_args_info.release_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "release", '-',
                additional_error))
              goto failure;
          
          }
          /* dummy.  */
          else if (strcmp (long_options[option_index].name, "exit") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->exit_flag), 0, &(args_info->exit_given),
                &(local_args_info.exit_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "exit", '-',
                additional_error))
              goto failure;
          
          }
          /* Shows example runs of alder-kmer.  */
          else if (strcmp (long_options[option_index].name, "examples") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->examples_flag), 0, &(args_info->examples_given),
                &(local_args_info.examples_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "examples", '-',
                additional_error))
              goto failure;
          
          }
          /* Shows the document for alder-kmer.  */
          else if (strcmp (long_options[option_index].name, "document") == 0)
          {
          
          
            if (update_arg((void *)&(args_info->document_flag), 0, &(args_info->document_given),
                &(local_args_info.document_given), optarg, 0, 0, ARG_FLAG,
                check_ambiguity, override, 1, 0, "document", '-',
                additional_error))
              goto failure;
          
          }
          
          break;
        case '?':	/* Invalid option.  */
          /* `getopt_long' already printed an error message.  */
          goto failure;

        default:	/* bug: option not considered.  */
          fprintf (stderr, "%s: option unknown: %c%s\n", MY_CMDLINE_PARSER_PACKAGE, c, (additional_error ? additional_error : ""));
          abort ();
        } /* switch */
    } /* while */



  if (check_required)
    {
      error_occurred += my_cmdline_parser_required2 (args_info, argv[0], additional_error);
    }

  my_cmdline_parser_release (&local_args_info);

  if ( error_occurred )
    return (EXIT_FAILURE);

  if (optind < argc)
    {
      int i = 0 ;
      int found_prog_name = 0;
      /* whether program name, i.e., argv[0], is in the remaining args
         (this may happen with some implementations of getopt,
          but surely not with the one included by gengetopt) */


      args_info->inputs_num = argc - optind - found_prog_name;
      args_info->inputs =
        (char **)(malloc ((args_info->inputs_num)*sizeof(char *))) ;
      while (optind < argc)
        args_info->inputs[ i++ ] = gengetopt_strdup (argv[optind++]) ;
    }

  return 0;

failure:
  
  my_cmdline_parser_release (&local_args_info);
  return (EXIT_FAILURE);
}
