package "alder-kmer"
version "0.1"
purpose "alder-kmer counts kmers in a sequence data set of FASTQ and FASTA files."
usage "alder-kmer [command] [OPTIONS]... [FILES]..."
description
"alder-kmer allows arbitrary size of kmer using multiple CPUs with compare-and-swap (CAS) instructions. The first argument of the alder-kmer is a command, which is one of the strings: `count', `dump', `query', `simulate', `partition', `kmer', `table', `list', `match', `binary', `uncompress', and `inspect'. Use option --help to see options for each command; e.g., alder-kmer count --help. Options may require arguments. `INT' is a positive number unless stated otherwise. `STRING' is a string of characters. `FILENAME' and `DIRECTORY' are strings that could be found or created in the file system that you run alder-kmer on. These are common options, which are followed by commands and their main options."

option "help" h "Print help of the program, or a command: e.g., alder-kmer count -h" flag off
option "detailed-help" - "Print help, including all details" flag off
option "full-help" - "Print help with documents" flag off

section "count"
sectiondesc="The input files must be sequence files: fasta, or fastq. With no input files, but with STDIN, version 2 or 3 runs are allowed because the number of kmers cannot be estimated without input files. In version 2 or 3, the first stage of generating a binary file would do the computation of total number of kmers, and STDIN can be used. With STDIN, version 2 or 3 is used. With input files, one of the three versions is used. By default, the table file would be written to STDOUT unless --outfile is specified. A table file is accompanied by its table header .tbh file. The numbers of iterations and partitions are determined by the available disk space, memory, and input sequence data (see Rizk et al. 2013 using --cite option). The program attempts to compute the available disk space and memory at the time the program runs. This help message shows the available disk space and memory below. Those values can be changed whenever the program runs, and they can be different from the ones below. You could specify disk space or available memory, and adjust the usage of disk space and memory using load options: --load-disk and --load-memory. You can also specify the number of iterations and partitions --ni and --np, these will override values that otherwise would be determined by disk space and input sequence data; this is not recommended for real data, but for command `simulate'. Output file name prefix can be changed using --outfile, and so can their location with --outdir. In version 6, the given total memory is filled with input data, and the memory left-over is used for a partition table. If the minimum memory for a partition table is not met, the version 6 is reduced to version 5. Because too large table may failed to be loaded onto the memory space in other computers, the maximum memory for a partition table can be set as well."
option "count" - "Count k-mer data" flag off
option "kmer" k "k-mer size" long typestr="INT" default="1" optional
option "disk" - "maximum disk space" long typestr="N MB" default="10" optional
option "load-disk" - "fraction of disk" double typestr="0 < x < 1" default="1.0" optional
option "memory" - "maximum memory" long typestr="N MB" default="10" optional
option "load-memory" - "fraction of memory" double typestr="0 < x < 1" default="1.0" optional
option "nthread" t "number of threads" long typestr="INT>=1" default="1" optional
option "outfile" o "prefix of output files" string typestr="STRING" default="outfile" optional
option "outdir" - "output directory" string typestr="DIRECTORY" default="." optional

option "nh" - "number of hash elements" long typestr="INT" default="10" optional
option "no-partition" - "Skip partitioning sequence files." flag off
option "no-count" - "Skip counting." flag off
option "no-delete" - "Do not delete partition files; on with --no-count" flag off

section "dump"
sectiondesc="This command reports the table of kmers and their occurences in a table file. The input file can be created either using `count', `table' or `simulate' command. A hash table file name is suffixed with `tbl'.  It prints k-mer, its reverse complementary sequence, the number of occurences, and the index of the sequence in the table."
option "report" - "Report the count table" flag off
option "summary" - "Display summary of the table" flag off
option "fasta" - "fasta format: >count newline kmer" flag off
option "no-tab" - "Space separator" flag off

section "query"
sectiondesc="Query a count table in a kmer count table; this is given by option --tabfile or the default name can be changed using option --outfile. A string of DNA sequence can be given with option --sequence, or a set of DNA sequences can be given by FASTA or FASTQ files."
option "query" - "dummy" flag off
option "sequence" - "Query a kmer DNA sequence" string typestr="sequence" optional

section "simulate"
sectiondesc="There are no input files for `simulate' command. Use --kmer to specifiy the length of kmer sequences. By default, a sequence file would be written to stdout if --nf option is given with 1 or a single sequence file is requested. Set the number of kmers using --maxkmer. FASTQ or FASTA files can be generated. A simple sequence file can also be created. Use --outfile and --outdir options to create files.  The command can generate sequence and partition files. Use --nf to change the number of files. Total number of parition files with .par extension is equal to ni x np where ni is given by option --ni and np is by --np.  See the reference papers for details using option --cite. Data size is limited by the number of kmers. Data size can also be limited by kmer size; e.g., however large the hash table size is, the number of slots would be two if kmer size is 1. If kmer size is very large, it is likely to have unique kmers."
option "simulate" - "Simulate k-mer data" flag off
option "maxkmer" - "number of kmers in a file" long typestr="INT < 10^8" default="1000" optional
option "format" - "generated sequence file format" string typestr="STRING" default="fastq" values="fasta","fastq","fa","fq","seq" enum optional
option "ni" - "number of iterations" long typestr="INT" default="1" optional
option "np" - "number of partitions" long typestr="INT" default="1" optional
option "nf" - "number of sequences files" long typestr="INT" default="1" optional
option "seqlen" - "maximum sequence length" long typestr="INT" default="100" optional
option "seed" - "random seed" long typestr="INT < 10^9" default="-1" optional
details="Enter a positive integer seed (9 digits or less)."

section "partition"
sectiondesc="This command converts sequence files to partition files. By default, it takes binary files; use option --use-fileseq if you want to use sequence files. To take a series of binary files, use option --binfile=STRING; STRING-0.bin to STRING-(#thread - 1).bin files are used as input files. Use options of command `simulate': --kmer, --nthread, --outfile, --outdir, --ni, and --np. You can use options: --disk and --memory to set automatically --ni and --np, but to use --disk and --memmory you must set --ni=-1 and --np=-1 or negative values. Otherwise, --ni and --np values in `simulate' command would be used. The --memory option value will be still used for acquiring buffers for reading sequence files and writing partition files. Large memory would increase the speed of `partition' command. On the contrary, the value in --disk does not affect the buffer, and the performance of `partition' command would be the same for different values of --disk, which would change the size of --ni and --np if --ni=-1 and --np=-1. See the reference by Rizk, et al. (2013) for details using option --cite."
option "partition" - "Create a partition file" flag off dependon="outfile"
option "inbuffer" - "Size of input buffer in log2" long typestr="INT" default="0" optional
option "outbuffer" - "Size of output buffer in log2" long typestr="INT" default="0" optional

section "kmer"
sectiondesc="This command converts a partition file to a kmer sequence file. Available options include --kmer, --outfile, and --outdir. Use the following commands to convert the decoded kmers to a dumped table.\n$cut -f 1 outfile.dec|sort|uniq -c|awk 'BEGIN{OFS=FS=\" \"} {tmp=$1;$1=$2;$2=tmp;print}' > outfile.2"
option "decode" - "Decode a partition file" flag off dependon="outfile"

section "table"
sectiondesc="This command converts partition files to a table file. Use the following options: --kmer, --nh, --nthread, and provide at least one partition file as an input file. A series of partition files can be used with option --parfile=x; x-a-b-c.par is a partition file for iteration a, partition b, and thread c."
option "table" - "Partition file" flag off dependon="outfile"

section "list"
sectiondesc="This command lists kmer sequences in a fastq file. Kmer sequences should have the four letters of A, C, G, and T. Any other characters, even a, c, g, or t, are considered not a valid DNA letter. Available options include kmer, seqlen."
option "list" - "List kmers in a text file. Options: kmer, seqlen" flag off

section "match"
sectiondesc="This command compares a table file and a set of input files. A set of sequence data can be given as either standard input or input files."
option "match" - "Compare a table file and input sequence data." flag off
option "tabfile" - "a table file" string typestr="FILENAME" default="outfile.tbl" optional

section "binary"
sectiondesc="This command converts input sequence data to a alder-kmer binary file."
option "binary" - "Create a binary file from sequence file." flag off

section "uncompress"
sectiondesc="This command converts alder-kmer binary files to a simple form of sequence file. Without --outfile option, the output goes to STDOUT. With --outfile option, a file with extension of .seq is created. This could be use to compare a binary file from FASTQ files; use\n$ awk 'NR % 4 == 2' file.fq > file.seq\nand compare file.seq and the outfile from uncompress command. Use command-line tool md5 to compare two files because files can be large."
option "uncompress" - "Create a simple form of a sequence file from an alder-kmer binary file." flag off

section "inspect"
sectiondesc="This command inspects the computer that alder-kmer runs on."
option "inspect" - "inspect command" flag off

section "more"
option "cite" - "Print reference papers" optional hidden
option "log" - "Log file using option outfile" string typestr="file" default="outfile.log" optional argoptional
option "progress" - "Display progress" flag off

option "loglevel" - "Log level" long typestr="level" values="0","1","2","3","4","5" default="1" optional dependon="log"

option "progress-to-stderr" - "Display progress number to stdandard error" flag off
option "totalmaxkmer" - "Skip counting maximum number of kmers in data, and use this number" long typestr="INT" default="0" optional
option "select-version" - "Select a version of kmer counting: 0 for automatic selction, 1 for skipping binary file creation (dsk mode with a single iteration), 2 for binary file creation (dsk mode), 3 for loading a whole input data on the memory (msk or memory streaming kmer mode), and 4 for splitting a binary file." long typestr="INT" default="5" values="0","1","2","3","4","5" optional
option "bin-outdir" - "binary file output directory" string typestr="DIRECTORY" default="." optional
option "par-outdir" - "partition files output directory" string typestr="DIRECTORY" default="." optional
option "tab-outdir" - "table file output directory" string typestr="DIRECTORY" default="." optional

option "mer-len" m "k-mer size" long typestr="INT" default="1" optional
option "canonical" C "Count both strand" flag off
option "lower-count" L "minimum count" long typestr="INT" default="1" optional
option "upper-count" U "maximum count" long typestr="INT" default="65535" optional
option "size" - "hash size" long typestr="INT" default="1" optional
option "threads" - "number of threads" long typestr="INT>=1" default="1" optional
option "output" - "prefix of output files" string typestr="STRING" default="outfile" optional

option "with-reverse" - "Print reverse complementary sequences" flag off
option "with-index" - "Print index values" flag off
option "only-init" - "Do not execute counting, but the initialization" flag off
option "with-parfile" - "Create par files as well as sequence files." flag off
option "min-table-memory" - "min memory of a part table" long typestr="INT" default="100" optional
option "max-table-memory" - "max memory of a part table" long typestr="INT" default="1000" optional
option "nsplit" - "split binary files" long typestr="INT" default="1" optional
option "use-seqfile" - "Use FASTQ or FASTA" flag off
option "binfile" - "prefix of binary files" string typestr="STRING" default="outfile" optional
option "parfile" - "prefix of partition files" string typestr="STRING" default="outfile" optional

option "release" - "Release mode" flag on

section "exit"
sectiondesc="The alder-kmer exit 0 on success, and >0 if an error occurs. The command `simulate' returns 0 if all of the Kmers occur only once, otherwise >0."
option "exit" - "dummy" flag off

section "examples"
sectiondesc="The alder-kmer can take files of different formats depending on the given command argument.

*** FILE FORMAT ***

FASTA: See http://en.wikipedia.org/wiki/FASTA_format for the format. Command `simulate' can create fasta-format files.

FASTQ: See http://en.wikipedia.org/wiki/FASTQ_format for the format. Command `simulate' can create fastq-format files.

TAB: This is a binary file format for files created by alder-kmer `count' command. It contains a list of entries, of which each consists of a kmer, its occurence, and the index. The index value could be used to search the table for a particular kmer. Another command named `table' can create a table file from a partition file.

BIN: Alder-kmer converts a set of input sequence files to a .bin file. A binary file tends to be smaller in size, which allows alder-kmer to read a whole input in each iteration more quickly than read sequence files. A binary file is not created if only one iteration is estimated to be needed.

PAR: This is a binary file format for a partition. See Rizk et al. (2013) for details of partitions. A file of the format contains kmer sequences of the same kmer size. Commands `count'. `simulate', and `partition' can create partition files.

DEC: This is a text file format of partition files. It simply prints one kmer per line.

*** COUNT ***

Use one of the commands to execute alder-kmer. When demontrating usages of alder-kmer, the first argument being always a command, I omit alder-kmer. For instance, to count kmer of size 1 in file a.fa you can type in the following command:
$ ./alder-kmer count a.fa
Instead, we write as follows:
$ count a.fa
So, please, always prepend the command with `alder-kmer'. If you need a test sequence file, then see a following section to learn how to use `simulate' command, which would create sequence files.

To count kmers (K=2) in a sequence file, using option -k, type in:
$ count -k 2 a.fa
This would create an output file named outfile.tbl.

*** REPORT ***

To list kmers and their occurences in a created hash table, type in:
$ report outfile.tbl

*** SIMULATE ***

Create a sequence file using `simulate' command.
$ simulate --seed=1
The command runs with default options. See the secion `simulate' command above for detail or type in:
$ simulate -h
to learn options and default values of the command. The `simulate' command would create a sequence file (outfile-00.fa) and a partition file (outfile_0-0.par).

*** PARTITION ***

Let's recover the same partition file, which is a part of command `count' using command `partition'.
$ partition outfile-00.fa
Because this command is part of simulation, it uses more options in command `simulate' than those in `count'. The command would create a partition file: outfile-0-0.par. This file and outfile_0-0.par should be same.  The partition file contains kmers in bytes, which can be decoded by using command `decode' with the partition file.

*** DECODE ***

To convert a partition file to a text file, type in:
$ decode outfile-0-0.par
The `decode' command generates an out file with .dec extension.

*** TABLE ***

To create the report file from a partition file, type in:
$ table outfile-0-0.par
This would create an output file named outfile.tbl.

*** LIST ***

*** MATCH ***

*** BINARY ***

*** UNCOMPRESS ***

$ ./alder-kmer u outfile.bin | md5
$ cat outfile.bin | ./alder-kmer u | md5

*** INSPECT ***

*** EXAMPLES ***

Let's consider these variables in testing.
K: kmer size
N: number of unique kmers (MAX of N=10^8)
M: occurence of each unique kmer
T: number of threads

1. Partition command test without consistency check (.fa/.fq -> .par)
K=1..62,N=10000,M=65535,T=1 
./alder_kmer_test_partition.sh $K 10000 65535 fq no 1 3
K=1..62,N=10000,M=65535,T=4 (1 hour)
for K in {1..62}; do ./alder_kmer_test_partition.sh $K 10000 65535 fq no 4 3; done

2. Table command test (.par -> .tbl)
K=1..62,N=1000,T=1
for K in {1..62}; do ./alder_kmer_test_table.sh $K 1000 fq no 1; done
K=1..62,N=1000,T=4
for K in {1..62}; do ./alder_kmer_test_table.sh $K 100000 fq no 4; done

3. Table command with larger data test
K=15..31,T=1
./alder_kmer_test_table2.sh $K 10000 65535 fq no 10000 1000 1 3
K=15..31,T=4
for K in {32..186}; do ./alder_kmer_test_table2.sh $K 10000 65535 fq no 10000 1000 4 3; done
HERE

4. Count command test (.fa/.fq -> .tbl)
K=15..63,T=1
./alder_kmer_test_count.sh $K 10000 65535 fq no 10000 1000 1 3
K=15..186,T=4
for K in {32..186}; do ./alder_kmer_test_count.sh $K 10000 65535 fq no 10000 1000 4 3; done
NEXT

5. Maximum of unique test
./alder_kmer_test_partition.sh 15 100000000 1 fq no 1 3

6. Shuffle
K=32..200
for K in {32..99}; do ./alder_kmer_test_table3.sh $K 1000 fq no 10000 10 4 3 no; done
HERE on upto 99 because of lack of disk space.
for K in {32..99}; do ./alder_kmer_test_table3.sh $K 1000 fq no 10000 10 4 3 yes; done
NEXT (partially)

7. dsk's human data test using alder-kmer's list command


8. Multiple input files

. lz4

. FASTA

. gzip, bzip2

. dsk's test data

. K=32 .. 186

. T=1 .. 128 (using pacman and lemming)

. Test of overflow of occurence (create a separate file of kmer of overflowed).
.ofl file would contain encoded numbers just like .par file.


TODO
3. Usage of table in percentage (should be 70%)


Simpel Check of version 3
./alder-kmer s -k 25 --maxkmer=100000 -o outfile
./alder-kmer binary outfile-00.fq
./alder-kmer partition -k 25 --binfile=outfile --nthread=1
./alder-kmer kmer -k 25 outfile-0-0-0.par -o outfile
cut -f 1 outfile.dec|sort|uniq -c|awk 'BEGIN{OFS=FS=\" \"} {tmp=$1;$1=$2;$2=tmp;print}' > outfile.2
./alder-kmer table -k 25 --parfile=outfile --nthread=1
./alder-kmer d outfile.tbl > outfile.1
cut -f 1 outfile.1|sort|uniq -c|awk 'BEGIN{OFS=FS=\" \"} {tmp=$1;$1=$2;$2=tmp;print}' > outfile.1.2
diff outfile.1.2 outfile.2

### End of Examples ###"
option "examples" - "Shows example runs of alder-kmer" flag off

section "document"
sectiondesc="Title

Abstract
Counting K-mers in a nucleotide sequence data set is a basic step in further analyses of the data. Computing environments can be diverse from personal computers to high-end super computers. Diverse computing environments are equiped with different limiting factors in terms of disk space, available memory, and CPUs. Computing costs time and enerage. Efficient use of available resources is important. I could have saved time and spend the spare time on something else. Someone else could have used the resources for their use. If disk space is cheaper than memory in computing environments such as personal computers, using disk space would be beneficial. Disk space may not be available in some high-end super computing environments, but more computer memory could be available. I experiment with counting K-mers in different computing environments to address which resources are limiting factors.

Introduction




Limited factors.
1. Disk space. Usually disk space is unlimited. In high-end computing facilities, disk space tends to be more expensive than memory or available CPUs. Reading and writing compressed files can be crucial in this disk space limited computing environment.
2. Memory. Loading all of the sequence data in a single memory would allow me to bypass the generation of partition files, and directly create a resulting table file.
3. CPU cores. I cannot compensate limited memory by multiple CPUs.

Limted disk

Input data - 460g (uncompressed) 130g (gz compressed) 100g (bz2 compressed) 130g (lz4 compressed)
disk space - 100m, 1g, 10g, 100g, 1000g
memory     - 100m, 1g, 2g, 4g, 8g, 16g, 32g, 64g, (128g, 256g, 512g, 1024g, 2048g)
CPU        - 1, 2, 4, 8, 24, 16, 32, 64, 128
K          - 1 ... 256

Phases (compress, partition, table)
1. compress  - sequence data to a binary file
2. partition - a binary file to multiple partition files
3. table     - partition files to a table file

1. A single iteration - partition and table
2. large memory - compress and table

If the available memory is large enough to load a whole data set, I could bypass the partition step and write the table directly.

I would avoid comparing alder-kmer with dsk or kmc because they are similar in many ways. Besides, they are not as popular as Jellyfish. The CAS is a key difference from dsk or kmc. I want to make a case that CAS with dsk or kmc scheme would improve the disk-streaming kmer counting method in the computing speed.

Differences from Jellyfish, dsk, kmc
1. Jellyfish - a table is made per partition
2. dsk - uses lock-free scheme or Jellyfish approach if more memory is available
3. kmc - uses lock-free scheme

Commons with Jellyfish, dsk, kmc
1. Jellyfish - using CAS
2. dsk - same when the memory is limited
3. kmc - delicate multi-threaded design

Methods

Results

Discussions

References


Jellyfish

Marçais, G. & Kingsford, C. A fast, lock-free approach for efficient parallel counting of occurrences of k-mers. Bioinformatics, Department of Computer Science, University of Maryland, College Park, MD 20742, USA. gmarcais@umd.edu, 2011, 27, 764-770

dsk (minia)

Rizk, G.; Lavenier, D. & Chikhi, R. DSK: k-mer counting with very low memory usage. Bioinformatics, Algorizk, 75013 Paris, France., 2013, 29, 652-653

kmc

Deorowicz, S.; Debudaj-Grabysz, A. & Grabowski, S. Disk-based k-mer counting on a PC. BMC Bioinformatics, Institute of Informatics, Silesian University of Technology, Akademicka 16, 44-100 Gliwice, Poland. sebastian.deorowicz@polsl.pl, 2013, 14, 160

BFCounter

Melsted, Pá. & Pritchard, J. K. Efficient counting of k-mers in DNA sequences using a bloom filter. BMC Bioinformatics, Department of Human Genetics, The University of Chicago, Chicago, IL 60637, USA. pmelsted@gmail.com, 2011, 12, 333

khmer

Pell, J.; Hintze, A.; Canino-Koning, R.; Howe, A.; Tiedje, J. M. & Brown, C. T. Scaling metagenome sequence assembly with probabilistic de Bruijn graphs Proceedings of the National Academy of Sciences, National Acad Sciences, 2012, 109, 13272-13277
https://github.com/ctb/khmer

de Bruijn graphs

Compeau, P. E.; Pevzner, P. A. & Tesler, G. How to apply de Bruijn graphs to genome assembly Nature biotechnology, Nature Publishing Group, 2011, 29, 987-991

### End of Document ###"
option "document" - "Shows the document for alder-kmer" flag off

