package "alder-kmer"
version "0.1"
purpose "alder-kmer counts kmers in a sequence data set of FASTQ and FASTA files."
usage "alder-kmer [command] [OPTIONS]... [FILES]..."
description
"alder-kmer allows arbitrary size of kmer using multiple CPUs. The first argument of the alder-kmer is a command, which is one of the strings: `count', `report', `simulate', `partition', `decode', `table', `list', `match', `binary', `uncompress', and `inspect'. Use option --help to see options for each command; e.g., alder-kmer count --help. Options may require arguments. `INT' is a positive number unless stated otherwise. `STRING' is a string of characters. `FILENAME' and `DIRECTORY' are strings that could be found or created in the file system that you run alder-kmer on."

option "help" h "Print help of the program, or a command: e.g., alder-kmer count -h" flag off
option "detailed-help" - "Print help, including all details" flag off
option "full-help" - "Print help with documents" flag off

section "count"
sectiondesc="The following options are for counting kmers in a data set. The input files must be sequence files: fasta, or fastq. The numbers of iterations and partitions are determined by the available disk space, memory, and input sequence data (see Rizk et al. 2013 using --cite option). The program attempts to compute the available disk space and memory at the time the program runs. This help message even shows the available disk space and memory below. Those values can be changed whenever the program runs, and they can be different from the ones below. You could specify disk space or available memory, and adjust the usage of disk space and memory using load options: --load-disk and --load-memory. You can also specify the number of iterations and partitions --ni and --np, these will override values that otherwise would be determined by disk space and input sequence data; this is not recommended for real data, but for command `simulate'. The program would use about half the number of CPU cores. Change the number of cores or threads as you wish. Output file name prefix can be changed using --outfile, and so can their location with --outdir."
option "count" - "Count k-mer data" flag off
option "kmer" k "k-mer size" long typestr="INT" default="1" optional
option "disk" d "maximum disk space" long typestr="N MB" default="10" optional
option "load-disk" - "fraction of disk" double typestr="0 < x < 1" default="1.0" optional
option "memory" m "maximum memory" long typestr="N MB" default="10" optional
option "load-memory" - "fraction of memory" double typestr="0 < x < 1" default="1.0" optional
option "nthread" t "number of threads" long typestr="INT>=1" default="1" optional
option "outfile" o "prefix of output files" string typestr="FILENAME" default="outfile" optional
option "outdir" - "output directory" string typestr="DIRECTORY" default="." optional
option "nh" - "number of elements in a hash table" long typestr="INT" default="10" optional
option "no-partition" - "Use partitions not sequence files." flag off
option "no-count" - "Do only partitions not counting." flag off
option "no-delete" - "Do not delete partition files; on with --no-count" flag off

section "report"
sectiondesc="This command reports the table of kmers and their occurences in a table file. The input file can be created either using `count', `table' or `simulate' command. A hash table file name is suffixed with `tbl'.  It prints k-mer, its reverse complementary sequence, the number of occurences, and the index of the sequence in the table."
option "report" - "Report the count table" flag off
option "summary" s "Display summary of the table" flag off
option "query" q "Query a kmer DNA sequence" string typestr="sequence" optional

section "simulate"
sectiondesc="The following options are for simulating a data set. There are io input files for `simulate' command. Use --kmer to specifiy the length of kmer sequences, and --outfile and --outdir to change the out file prefix. See the reference papers for details using option --cite. The command generates sequence and partition files. Use --nf to change the number of files. Total number of parition files with .par extension is equal to ni x np where ni is given by option --ni and np is by --np. Data size is limited by the size of hash table and the maximum count in a slot. The larger maximum count, the greater the data size. Data size can also be limited by kmer size; e.g., however large the hash table size is, the number of slots would be two if kmer size is 1. If kmer size is very large, hash table size would also determine data size. You can use --ni and --np in `count' command where these two values are set by disk space and memory."
option "simulate" - "Simulate k-mer data" flag off dependon="outfile"
option "maxkmer" - "number of kmers in a file" long typestr="INT < 10^8" default="1000" optional
option "format" - "generated sequence file format" string typestr="STRING" default="fastq" values="fasta","fastq","fa","fq","seq" enum optional
option "ni" - "number of iterations" long typestr="INT" default="1" optional
option "np" - "number of partitions" long typestr="INT" default="1" optional
option "nf" - "number of sequences files" long typestr="INT" default="1" optional
option "seqlen" - "maximum sequence length" long typestr="INT" default="100" optional
option "seed" - "random seed" long typestr="INT < 10^9" default="-1" optional
details="Enter a positive integer seed (9 digits or less)."

section "partition"
sectiondesc="This command converts sequence files to partition files. Use options of command `simulate': --kmer, --nthread, --outfile, --outdir, --ni, and --np. You can use options: --disk and --memory to set automatically --ni and --np, but to use --disk and --memmory you must set --ni=-1 and --np=-1 or negative values. Otherwise, --ni and --np values in `simulate' command would be used. The --memory option value will be still used for acquiring buffers for reading sequence files and writing partition files. Large memory would increase the speed of `partition' command. On the contrary, the value in --disk does not affect the buffer, and the performance of `partition' command would be the same for different values of --disk, which would change the size of --ni and --np if --ni=-1 and --np=-1. See the reference by Rizk, et al. (2013) for details using option --cite."
option "partition" - "Create a partition file" flag off dependon="outfile"
option "inbuffer" - "Size of input buffer in log2" long typestr="INT" default="0" optional
option "outbuffer" - "Size of output buffer in log2" long typestr="INT" default="0" optional

section "decode"
sectiondesc="This command converts a partition file to a sequence file. Available options include --kmer, --outfile, and --outdir."
option "decode" - "Decode a partition file" flag off dependon="outfile"

section "table"
sectiondesc="This command converts partition files to a table file. Use the following options: --kmer, --nh, --nthread, and provide at least one partition file as an input file."
option "table" - "Partition file" flag off dependon="outfile"

section "list"
sectiondesc="This command lists kmer sequences in a fastq file. Kmer sequences should have the four letters of A, C, G, and T. Any other characters, even a, c, g, or t, are considered not a valid DNA letter. Available options include kmer, seqlen."
option "list" - "List kmers in a text file. Options: kmer, seqlen" flag off

section "match"
sectiondesc="This command compares a table file and a set of input files. A set of sequence data can be given as either standard input or input files."
option "match" - "Compare a table file and input sequence data." flag off
option "tabfile" - "a table file" string typestr="FILENAME" default="outfile.tbl" optional

section "binary"
sectiondesc="This command converts input sequence data to a alder-kmer binary file."
option "binary" - "Create a binary file from sequence file." flag off

section "uncompress"
sectiondesc="This command converts an alder-kmer binary file to a simple form of sequence file."
option "uncompress" - "Create a simple form of a sequence file from an alder-kmer binary file." flag off

section "inspect"
sectiondesc="This command inspects the computer that alder-kmer runs on."
option "inspect" - "inspect command" flag off

section "more"
option "cite" - "Print reference papers" optional hidden
option "log" - "Log file using option outfile" string typestr="file" default="outfile.log" optional argoptional
option "progress" - "Display progress" flag off

option "loglevel" - "Log level" long typestr="level" values="0","1","2","3","4","5" default="1" optional
option "progress-to-stderr" - "Display progress number to stdandard error" flag off
option "totalmaxkmer" - "Skip counting maximum number of kmers in data, and use this number" long typestr="INT" default="0" optional
option "select-version" - "Select a version" long typestr="INT" default="0" values="0","4","5","6" optional
option "bin-outdir" - "binary file output directory" string typestr="DIRECTORY" default="." optional
option "par-outdir" - "partition files output directory" string typestr="DIRECTORY" default="." optional
option "tab-outdir" - "table file output directory" string typestr="DIRECTORY" default="." optional

section "exit"
sectiondesc="The alder-kmer exit 0 on success, and >0 if an error occurs. The command `simulate' returns 0 if all of the Kmers occur only once, otherwise >0."
option "exit" - "dummy" flag off

section "examples"
sectiondesc="The alder-kmer can take files of different formats depending on the given command argument.

*** FILE FORMAT ***

FASTA: See http://en.wikipedia.org/wiki/FASTA_format for the format. Command `simulate' can create fasta-format files.

FASTQ: See http://en.wikipedia.org/wiki/FASTQ_format for the format. Command `simulate' can create fastq-format files.

TAB: This is a binary file format for files created by alder-kmer `count' command. It contains a list of entries, of which each consists of a kmer, its occurence, and the index. The index value could be used to search the table for a particular kmer. Another command named `table' can create a table file from a partition file.

BIN: Alder-kmer converts a set of input sequence files to a .bin file. A binary file tends to be smaller in size, which allows alder-kmer to read a whole input in each iteration more quickly than read sequence files. A binary file is not created if only one iteration is estimated to be needed.

PAR: This is a binary file format for a partition. See Rizk et al. (2013) for details of partitions. A file of the format contains kmer sequences of the same kmer size. Commands `count'. `simulate', and `partition' can create partition files.

DEC: This is a text file format of partition files. It simply prints one kmer per line.


*** COUNT ***

Use one of the commands to execute alder-kmer. When demontrating usages of alder-kmer, the first argument being always a command, I omit alder-kmer. For instance, to count kmer of size 1 in file a.fa you can type in the following command:
$ ./alder-kmer count a.fa
Instead, we write as follows:
$ count a.fa
So, please, always prepend the command with `alder-kmer'. If you need a test sequence file, then see a following section to learn how to use `simulate' command, which would create sequence files.

To count kmers (K=2) in a sequence file, using option -k, type in:
$ count -k 2 a.fa
This would create an output file named outfile.tbl.

*** REPORT ***

To list kmers and their occurences in a created hash table, type in:
$ report outfile.tbl

*** SIMULATE ***

Create a sequence file using `simulate' command.
$ simulate --seed=1
The command runs with default options. See the secion `simulate' command above for detail or type in:
$ simulate -h
to learn options and default values of the command. The `simulate' command would create a sequence file (outfile-00.fa) and a partition file (outfile_0-0.par).

*** PARTITION ***

Let's recover the same partition file, which is a part of command `count' using command `partition'.
$ partition outfile-00.fa
Because this command is part of simulation, it uses more options in command `simulate' than those in `count'. The command would create a partition file: outfile-0-0.par. This file and outfile_0-0.par should be same.  The partition file contains kmers in bytes, which can be decoded by using command `decode' with the partition file.

*** DECODE ***

To convert a partition file to a text file, type in:
$ decode outfile-0-0.par
The `decode' command generates an out file with .dec extension.

*** TABLE ***

To create the report file from a partition file, type in:
$ table outfile-0-0.par
This would create an output file named outfile.tbl.

*** MATCH ***

*** BINARY ***

*** UNCOMPRESS ***

*** INSPECT ***

*** EXAMPLES ***

Let's consider these variables in testing.
K: kmer size
N: number of unique kmers (MAX of N=10^8)
M: occurence of each unique kmer
T: number of threads

1. Partition command test without consistency check (.fa/.fq -> .par)
K=1..62,N=10000,M=65535,T=1 
./alder_kmer_test_partition.sh $K 10000 65535 fq no 1 3
K=1..62,N=10000,M=65535,T=4 (1 hour)
for K in {1..62}; do ./alder_kmer_test_partition.sh $K 10000 65535 fq no 4 3; done

2. Table command test (.par -> .tbl)
K=1..62,N=1000,T=1
for K in {1..62}; do ./alder_kmer_test_table.sh $K 1000 fq no 1; done
K=1..62,N=1000,T=4
for K in {1..62}; do ./alder_kmer_test_table.sh $K 100000 fq no 4; done

3. Table command with larger data test
K=15..31,T=1
./alder_kmer_test_table2.sh $K 10000 65535 fq no 10000 1000 1 3
K=15..31,T=4
for K in {32..186}; do ./alder_kmer_test_table2.sh $K 10000 65535 fq no 10000 1000 4 3; done
HERE

4. Count command test (.fa/.fq -> .tbl)
K=15..63,T=1
./alder_kmer_test_count.sh $K 10000 65535 fq no 10000 1000 1 3
K=15..186,T=4
for K in {32..186}; do ./alder_kmer_test_count.sh $K 10000 65535 fq no 10000 1000 4 3; done
NEXT

5. Maximum of unique test
./alder_kmer_test_partition.sh 15 100000000 1 fq no 1 3

6. Shuffle
K=32..200
for K in {32..99}; do ./alder_kmer_test_table3.sh $K 1000 fq no 10000 10 4 3 no; done
HERE on upto 99 because of lack of disk space.
for K in {32..99}; do ./alder_kmer_test_table3.sh $K 1000 fq no 10000 10 4 3 yes; done
NEXT (partially)

7. dsk's human data test using alder-kmer's list command


8. Multiple input files

. lz4

. FASTA

. gzip, bzip2

. dsk's test data

. K=32 .. 186

. T=1 .. 128 (using pacman and lemming)

. Test of overflow of occurence (create a separate file of kmer of overflowed).
.ofl file would contain encoded numbers just like .par file.

TODO
3. Usage of table in percentage (should be 70%)

### End of Examples ###"
option "examples" - "Shows example runs of alder-kmer" flag off

section "document"
sectiondesc="Title

Abstract
Counting K-mers in a nucleotide sequence data set is a basic step in further analyses of the data. Computing environments can be diverse from personal computers to high-end super computers. Diverse computing environments are equiped with different limiting factors in terms of disk space, available memory, and CPUs. Computing costs time and enerage. Efficient use of available resources is important. I could have saved time and spend the spare time on something else. Someone else could have used the resources for their use. If disk space is cheaper than memory in computing environments such as personal computers, using disk space would be beneficial. Disk space may not be available in some high-end super computing environments, but more computer memory could be available. I experiment with counting K-mers in different computing environments to address which resources are limiting factors.

Introduction




Limited factors.
1. Disk space. Usually disk space is unlimited. In high-end computing facilities, disk space tends to be more expensive than memory or available CPUs. Reading and writing compressed files can be crucial in this disk space limited computing environment.
2. Memory. Loading all of the sequence data in a single memory would allow me to bypass the generation of partition files, and directly create a resulting table file.
3. CPU cores. I cannot compensate limited memory by multiple CPUs.

Limted disk

Input data - 460g (uncompressed) 130g (gz compressed) 100g (bz2 compressed) 130g (lz4 compressed)
disk space - 100m, 1g, 10g, 100g, 1000g
memory     - 100m, 1g, 2g, 4g, 8g, 16g, 32g, 64g, (128g, 256g, 512g, 1024g, 2048g)
CPU        - 1, 2, 4, 8, 24, 16, 32, 64, 128
K          - 1 ... 256

Phases (compress, partition, table)
1. compress  - sequence data to a binary file
2. partition - a binary file to multiple partition files
3. table     - partition files to a table file

1. A single iteration - partition and table
2. large memory - compress and table

If the available memory is large enough to load a whole data set, I could bypass the partition step and write the table directly.

I would avoid comparing alder-kmer with dsk or kmc because they are similar in many ways. Besides, they are not as popular as Jellyfish. The CAS is a key difference from dsk or kmc. I want to make a case that CAS with dsk or kmc scheme would improve the disk-streaming kmer counting method in the computing speed.

Differences from Jellyfish, dsk, kmc
1. Jellyfish - a table is made per partition
2. dsk - uses lock-free scheme or Jellyfish approach if more memory is available
3. kmc - uses lock-free scheme

Commons with Jellyfish, dsk, kmc
1. Jellyfish - using CAS
2. dsk - same when the memory is limited
3. kmc - delicate multi-threaded design

Methods

Results

Discussions

References


Jellyfish

Marçais, G. & Kingsford, C. A fast, lock-free approach for efficient parallel counting of occurrences of k-mers. Bioinformatics, Department of Computer Science, University of Maryland, College Park, MD 20742, USA. gmarcais@umd.edu, 2011, 27, 764-770

dsk (minia)

Rizk, G.; Lavenier, D. & Chikhi, R. DSK: k-mer counting with very low memory usage. Bioinformatics, Algorizk, 75013 Paris, France., 2013, 29, 652-653

kmc

Deorowicz, S.; Debudaj-Grabysz, A. & Grabowski, S. Disk-based k-mer counting on a PC. BMC Bioinformatics, Institute of Informatics, Silesian University of Technology, Akademicka 16, 44-100 Gliwice, Poland. sebastian.deorowicz@polsl.pl, 2013, 14, 160

BFCounter

Melsted, Pá. & Pritchard, J. K. Efficient counting of k-mers in DNA sequences using a bloom filter. BMC Bioinformatics, Department of Human Genetics, The University of Chicago, Chicago, IL 60637, USA. pmelsted@gmail.com, 2011, 12, 333

khmer

Pell, J.; Hintze, A.; Canino-Koning, R.; Howe, A.; Tiedje, J. M. & Brown, C. T. Scaling metagenome sequence assembly with probabilistic de Bruijn graphs Proceedings of the National Academy of Sciences, National Acad Sciences, 2012, 109, 13272-13277
https://github.com/ctb/khmer

de Bruijn graphs

Compeau, P. E.; Pevzner, P. A. & Tesler, G. How to apply de Bruijn graphs to genome assembly Nature biotechnology, Nature Publishing Group, 2011, 29, 987-991

### End of Document ###"
option "document" - "Shows the document for alder-kmer" flag off
