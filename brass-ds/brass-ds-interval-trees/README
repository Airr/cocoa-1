To build it from a given list of n intervals, we first build the search tree for the interval endpoints in O(nlogn) time. Next we construct a list of the intervals sorted in decreasing order of their left interval endpoints, in O (n log n), and find for each interval the node where it should be stored, and insert it there in front of the left list, in O(logn) per interval. Finally, we construct a list of the intervals sorted in increasing order of their right interval endpoints, in O(nlogn), and find for each interval the node where it should be stored, and insert it there in front of the right list, in O (log n) per interval. By this initial sorting and inserting in that order, all node lists are in the correct order.

First, we can reduce the case where an interval R is given as input to the simpler case where a single point is given as input. We first find all ranges with beginning or end points inside the input interval R using a separately constructed tree. In the one-dimensional case, we can use a simple tree containing all the beginning and ending points in the interval set, each with a pointer to its corresponding interval.

A binary search in O(log n) time for the beginning and end of R reveals the minimum and maximum points to consider. Each point within this range references an interval that overlaps our range and is added to the result list. Care must be taken to avoid duplicates, since an interval might both begin and end within R. This can be done using a binary flag on each interval to mark whether or not it has been added to the result set.

The only intervals not yet considered are those overlapping R that do not have an endpoint inside R, in other words, intervals that enclose it. To find these, we pick any point inside R and use the algorithm below to find all intervals intersecting that point (again, being careful to remove duplicates).